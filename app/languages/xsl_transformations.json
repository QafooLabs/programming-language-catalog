{"name":"XSLT","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/XSL_Transformations","description":["XSLT (Extensible Stylesheet Language Transformations) is a declarative, XML-based language used for the transformation of XML documents. The original document is not changed; rather, a new document is created based on the content of an existing one. The new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text. XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.","Applications often use XSLT to convert XML data into HTML or XHTML documents for display as a web page. The transformation may happen dynamically either on a client or on a server, or it may be done as part of the publishing process. It is also used to create output for printing or direct video display, typically by transforming the original XML into XSL Formatting Objects to create formatted output which can then be converted to a variety of formats, including PDF, PostScript and PNG. XSLT can also translate XML messages between different XML schemas, or make changes to documents within the scope of a single schema, for example by removing the parts of a message that are not needed.","XSLT is developed by the World Wide Web Consortium (W3C). The most recent version is XSLT 2.0, which reached W3C recommendation status on 23 January 2007. As of 2010, however, XSLT 1.0 is still widely used, as there are no products that support XSLT 2.0 running in the browser, nor on some important server environments such as LAMP.","Originally, XSLT was part of the W3C's Extensible Stylesheet Language (XSL) development effort of 1998\u20131999, a project that also produced XSL Formatting Objects and the XML Path Language, XPath. The editor of the first version was James Clark. XSLT 1.0 was published as a Recommendation by the W3C on 16 November 1999. After an abortive attempt to create a version 1.1 in 2001, the XSL working group joined forces with the XQuery working group to create XPath 2.0, with a richer data model and type system based on XML Schema. XSLT 2.0, developed under the editorship of Michael Kay, was built on this foundation in 2002\u20132006.","As a language, XSLT is influenced by functional languages, and by text-based pattern matching languages in the tradition of SNOBOL and awk. Its most direct predecessor was ISO DSSSL, a language that performed the same function for full SGML that XSLT performs for XML (Some members of the standards committee that developed XSLT, including James Clark, had previously worked on DSSSL.) Unlike DSSSL, however, XSLT code uses the syntax of its target language, XML, which means that it can also be viewed as a Turing-completetemplate processor.","Most of this article is applicable to both XSLT versions; any differences are noted in the text.","The XSLT processing model involves:","The XSLT processor ordinarily takes two input documents\u2014an XML source document, and an XSLT stylesheet\u2014and produces an output document. The XSLT stylesheet contains a collection of template rules: instructions and other directives that guide the processor in the production of the output document.","The XSLT language is declarative: rather than listing an imperative sequence of actions to perform in a stateful environment, template rules only define how to handle a node matching a particular XPath-like pattern, if the processor should happen to encounter one, and the contents of the templates effectively comprise functional expressions that directly represent their evaluated form: the result tree, which is the basis of the processor's output.","The processor follows a fixed algorithm: assuming a stylesheet has already been read and prepared, the processor builds a source tree from the input XML document. It then starts by processing the source tree's root node, finding in the stylesheet the best-matching template for that node, and evaluating the template's contents. Instructions in each template generally direct the processor to either create nodes in the result tree, or process more nodes in the source tree in the same way as the root node. Output is derived from the result tree.","XSLT processor implementations fall into two main categories: client-side and server-side.","Client-side XSLT adoption has been slow due to widespread deployment of older (or alternative) browsers without XSLT support. As of mid-2012, most modern browsers have support for XSLT 1.0 built in. None supports XSLT 2.0 natively, but the third party Saxon-CE product aims to fill this gap.","Historically, early adopters of client-side XSLT included Microsoft Internet Explorer 6 (since 2001) and Netscape 7 (since 2002). Earlier still, Internet Explorer 5 supported XSLT\u2019s draft specification since 1999 or earlier, although it was incompatible with the final W3C specification. Netscape 6 included partial support since 2000.","Server-side XSLT processors (a somewhat misleading term, as they don\u2019t require a server to function; the name is intended to contrast with \u201cclient-side\u201d) exist as both standalone products and components of other software. This includes web browsers, application servers, frameworks (such as Java and .NET), or even operating systems. For example, Windows XP\u2019s MSXML3 library includes an XSLT 1.0 processor. The GNOME desktop environment 2 includes libxslt, an open source implementation with complete support for the XSLT 1.0 specification. The libxslt library is also used by other software, such as WebKit. Other examples include Apache\u2019s Xalan and Saxon XSLT (which supports XSLT 2.0 as well).","Most early XSLT processors were interpreters. More recently, code generation is increasingly common, using portable intermediate languages (such as Java bytecode or .NET Common Intermediate Language) as the target. However, even the interpretive products generally offer separate analysis and execution phases, allowing an optimized expression tree to be created in memory and reused to perform multiple transformations. This gives substantial performance benefits in online publishing applications, where the same transformation is applied many times per second to different source documents. This separation is reflected in the design of XSLT processing APIs (such as JAXP).","Early XSLT processors had very few optimizations. Stylesheet documents were read into Document Object Models and the processor would act on them directly. XPath engines were also not optimized. Increasingly, however, XSLT processors use optimization techniques found in functional programming languages and database query languages, such as static rewriting of an expression tree (e.g., to move calculations out of loops), and lazy pipelined evaluation to reduce the memory footprint of intermediate results (and allow \"early exit\" when the processor can evaluate an expression such as following-sibling::* without a complete evaluation of all subexpressions). Many processors also use tree representations that are significantly more efficient (in both space and time) than general-purpose DOM implementations.","XSLT 1.0 and XSLT 2.0 were not designed to allow XML Streaming of the input to output. The whole input document had to be read into memory before it could be processed.","Future implementations, like XSLT 3.0, may allow XML streaming, to reduce latency between the input and the output. It is especially important when transformations are chained together in XML Pipelines, for example in XProc.","XSLT relies upon the W3C's XPath language for identifying subsets of the source document tree, as well as for performing calculations. XPath also provides a range of functions, which XSLT itself further augments. This reliance upon XPath adds a great deal of power and flexibility to XSLT.","XSLT 1.0 uses XPath 1.0. Similarly, XSLT 2.0 relies on XPath 2.0; both specifications were published on the same date.","XSLT capabilities overlap with XQuery, which was initially conceived as a query language for large collections of XML documents.","The XSLT 2.0 and XQuery 1.0 standards were developed by separate working groups within W3C, working together to ensure a common approach where appropriate. They share the same data model, type system, and function library, and both include XPath 2.0 as a sublanguage.","The two languages, however, are rooted in different traditions and serve the needs of different communities. XSLT was primarily conceived as a stylesheet language whose primary goal was to render XML for the human reader on screen, on the web (as web template language), or on paper. XQuery was primarily conceived as a database query language in the tradition of SQL.","Because the two languages originate in different communities, XSLT is stronger in its handling of narrative documents with more flexible structure, while XQuery is stronger in its data handling, for example when performing relational joins.[citation needed]","As of 2009, there is no MIME\/Internet media type registered for XSLT.","The XSLT 1.0 Recommendation (1999) says \"The MIME media types text\/xml and application\/xml should be used for XSLT stylesheets. It is possible that a media type will be registered specifically for XSLT stylesheets; if and when it is, that media type may also be used.\" It goes on to use text\/xml in an example of how to embed a stylesheet with the xml-stylesheet processing instruction.","RFC 3023 points out potential technical problems with text\/* types in general, and proposes application\/xslt+xml as an ideal media type for XSLT. The XSLT 2.0 Recommendation (January 2007) includes a formal application to register this media type. However, at the time of writing (January 2009) the process of registration has not yet been completed, and RFC 3023 warns that \"... this media type should not be used until such registration has been completed.\"","Pre-1.0 working drafts of XSLT used text\/xsl in their embedding examples, and this type was implemented and continues to be promoted by Microsoft in Internet Explorer and MSXML. It is also widely recognized in the xml-stylesheet processing instruction by other browsers. In practice, therefore, users wanting to control transformation in the browser using this processing instruction are obliged to use this unregistered media type.","Sample of incoming XML document","This XSLT stylesheet provides templates to transform the XML document:","Its evaluation results in a new XML document, having another structure:","Processing the following example XSLT file","with the XML input file shown above results in the following XHTML (whitespace has been adjusted here for clarity):","This XHTML generates the output below when rendered in a web browser.","In order for a web browser to be able automatically to apply an XSL transformation to an XML document on display, an XML stylesheet processing instruction can be inserted into XML. So, for example, if the stylesheet in Example 2 above were available as \"example2.xsl\", the following instruction could be added to the original incoming XML:","(In this example, text\/xsl is technically incorrect according to the W3C specifications, but it is the only media type that is widely supported across current (2009) browsers.)"]}