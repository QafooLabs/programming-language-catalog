{"name":"ALGOL 68","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/ALGOL_68","description":["ALGOL 68 (short for ALGOrithmic Language 1968) is an imperative computer programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics.","Contributions of ALGOL 68 to the field of computer science are deep and wide ranging, although some of them were not publicly identified until they were passed, in one form or another, to one of many subsequently developed programming languages.","ALGOL 68 features include expression-based syntax, user-declared types and structures\/tagged-unions, a reference model of variables and reference parameters, string, array and matrix slicing, and also concurrency.","ALGOL 68 was designed by IFIP Working Group 2.1. On December 20, 1968 the language was formally adopted by Working Group 2.1 and subsequently approved for publication by the General Assembly of IFIP.","ALGOL 68 was defined using a two-level grammar formalism invented by Adriaan van Wijngaarden. Van Wijngaarden grammars use a context-free grammar to generate an infinite set of productions that will recognize a particular ALGOL 68 program; notably, they are able to express the kind of requirements that in many other programming language standards are labeled \"semantics\" and have to be expressed in ambiguity-prone natural language prose, and then implemented in compilers as ad hoc code attached to the formal language parser.","ALGOL 68 has been criticized, most prominently by some members of its design committee such as C. A. R. Hoare and Edsger Dijkstra, for abandoning the simplicity of ALGOL 60 becoming a vehicle for complex or overly general ideas, and doing little to make the compiler writer's task easy, in contrast to deliberately simple contemporaries (and competitors) such as C, S-algol and Pascal.","In 1970, ALGOL 68R became the first working compiler for ALGOL 68.","In the 1973 revision, certain features - such as proceduring, gommas and formal bounds - were omitted. c.f. The language of the unrevised report.","Though European defence agencies (in Britain Royal Signals and Radar Establishment - RSRE) promoted the use of ALGOL 68 for its expected security advantages, the American side of the NATO alliance decided to develop a different project, the Ada programming language, making its use obligatory for U.S. defense contracts.","Steve Bourne, who was on the Algol 68 revision committee, took some of its ideas to his Bourne shell (and thereby, to descendant shells such as Bash) and to C (and thereby to descendants such as C++).","The complete history of the project can be found in C.H. Lindsey's A History of ALGOL 68.","For a full length treatment of the language, see Programming Algol 68 Made Easy by Dr. Sian Leitch, or Learning Algol 68 Genie by Dr. Marcel van der Veer which includes the Revised Report.","On December 20, 1968 the \"Final Report\" (MR 101) was adopted by the Working Group, then subsequently approved by the General Assembly of UNESCO's IFIP for publication. Translations of the standard were made for Russian, German, French and Bulgarian, and then later Japanese. The standard was also made available in Braille. Subsequently ALGOL 68 became one of the GOST standards in Russia.","There are 61 such reserved words ( some with \"brief symbol\" equivalents ) in the standard sub-language:","The basic language construct is the unit. A unit may be a formula, an enclosed clause, a routine text or one of several technically needed constructs (assignation, jump, skip, nihil). The technical term enclosed clause unifies some of the inherently bracketting constructs known as block, do statement, switch statement in other contemporary languages. When keywords are used, generally the reversed character sequence of the introducing keyword is used for terminating the enclosure, eg. ( 'if' ~ then ~ else ~ 'fi', 'case' ~ in ~ out ~ 'esac', for ~ while ~ 'do' ~ 'od'). This feature was reused by Stephen Bourne in the common Unix Bourne shell. An expression may also yield a multiple value, which is constructed from other values by a collateral clause. This construct just looks like the parameter pack of a procedure call.","The basic data types (called modes in ALGOL 68 parlance) are real, int, compl (complex number), bool, char, bits and bytes. For example:","However, the declaration real x; is just syntactic sugar for ref real x = loc real;. That is, x is really the constant identifier for a reference to a newly generated local real variable.","Furthermore, instead of defining both float and double, or int and long and short, etc., ALGOL 68 provided modifiers, so that the presently common double would be written as long real or long long real instead, for example. Type queries of the kind of max real and min long int are provided to adapt programs to different implementations.","All variables need to be declared, the declaration does not have to appear prior to the first use.","primitive-declarer: int, real, compl, complexG, bool, char, string, bits, bytes, format, file, pipeG, channel, sema","Other declaration symbols include: flex, heap, loc, ref, long, short, eventS","A new mode (type) may be declared using a mode declaration:","This has the similar effect as the following C++ code:","Note that for ALGOL 68 only the newtype mode-indication appears to the left of the equals symbol, and most notably the construction is made - and can be read - from left to right without regard to priorities.","The coercions produce a coercend from a coercee according to three criteria: the a priori mode of the coercend before the application of any coercion, the a posteriori mode of the coercee required after those coercions, and the syntactic position or \"sort\" of the coercee. Coercions may be cascaded.","There are six possible coercions, termed \"deproceduring\", \"dereferencing\", \"uniting\", \"widening\", \"rowing\" and \"voiding\". Each Coercion, except \"uniting\", prescribes a corresponding dynamic effect on the associated values. Hence, a number of primitive actions can be programmed implicitly by coercions.","Context strength - Allowed coercions:","Pragmats are directives in the program, typically hints to the compiler. eg.","Comments can be inserted in variety of ways:","Normally, comments cannot be nested in ALGOL 68. This restriction can be circumvented by using different comment delimiters (e.g. use hash only for temporary code deletions).","ALGOL 68 being an expression-oriented programming language, the value returned by an assignment statement is a reference to the destination. Thus, the following is valid ALGOL 68 code:","This notion is present in C and Perl, among others. Note that half pi is a single identifier, i.e., blanks are ignored even within ALGOL 68 identifiers (effectively avoiding the underscores versus camel case versus all lower-case issues at once, but at the price of introducing a cornucopia of more serious problems in software engineering).","As another example, to express the mathematical idea of a sum of f(i) from i=1 to n, the following ALGOL 68 integer expression suffices:","Note that, being an integer expression, the former block of code can be used in any context where an integer value can be used. A block of code returns the value of the last expression it evaluated; this idea is present in Lisp, among other languages.","Compound statements are all terminated by distinctive (and somewhat reverent) closing brackets:","This scheme not only avoids the dangling else problem but also avoids having to use begin and end in embedded statement sequences.","Brief choice clause example:","Bold choice clause example:","Algol68 allowed the switch to be of either type int or (uniquely) union. The latter allows the enforcing strong typing onto union variables. c.f. union below for example.","This was considered the \"universal\" loop, the full syntax is:","There are several unusual aspects of the construct:","Subsequent \"extensions\" to the standard Algol68 allowed the to syntactic element to be replaced with upto and downto to achieve a small optimisation. The same compilers also incorporated:","Further examples can be found in the code examples below.","ALGOL 68 supports arrays with any number of dimensions, and it allows for the slicing of whole or partial rows or columns.","Matrices can be sliced either way, eg:","ALGOL 68 supports multiple field structures (struct) and united modes. Reference variables may point to any mode including array slices and structure fields.","For an example of all this, here is the traditional linked list declaration:","Usage example for union case of node:","Procedure (proc) declarations require type specifications for both the parameters and the result (void if none):","or, using the \"brief\" form of the conditional statement:","The return value of a proc is the value of the last expression evaluated in the procedure. References to procedures (ref proc) are also permitted. Call-by-reference parameters are provided by specifying references (such as ref real) in the formal argument list. The following example defines a procedure that applies a function (specified as a parameter) to each element of an array:","This simplicity of code was unachievable in ALGOL 68's predecessor ALGOL 60.","The programmer may define new operators and both those and the pre-defined ones may be overloaded. The following example defines operator max with both dyadic and monadic versions (scanning across the elements of an array).","These are technically not operators, rather they are considered \"units associated with names\"","\u201c:=:\u201d (alternatively \u201cis\u201d) tests if two pointers are equal; \u201c:\/=:\u201d (alternatively \u201cisnt\u201d) tests if they are unequal.","Why\u00a0:=: and\u00a0:\/=: are needed: Consider trying to compare two pointer values, such as the following variables, declared as pointers-to-integer:","Now consider how to decide whether these two are pointing to the same location, or whether one of them is pointing to nil. The following expression","will dereference both pointers down to values of type int, and compare those, since the \u201c=\u201d operator is defined for int, but not ref int. It is not legal to define \u201c=\u201d for operands of type ref int and int at the same time, because then calls become ambiguous, due to the implicit coercions that can be applied: should the operands be left as ref int and that version of the operator called? Or should they be dereferenced further to int and that version used instead? Therefore the following expression can never be made legal:","Hence the need for separate constructs not subject to the normal coercion rules for operands to operators. But there is a gotcha. The following expressions:","while legal, will probably not do what might be expected. They will always return false, because they are comparing the actual addresses of the variables ip and jp, rather than what they point to. To achieve the right effect, one would have to write","Patent application: On 14 May 2003, software patent application No. 20040230959 was filed for the ISNOT operator by employees of Microsoft. This patent was granted on 18 November 2004.","Most of Algol's \"special\" characters (\u00d7, \u00f7, \u2264, \u2265, \u2260, \u00ac, \u2283, \u2261, \u2228, \u2227, \u2192, \u2193, \u2191, \u230a, \u2308, \u23a9, \u23a7, \u22a5, \u23e8, \u00a2, \u25cb and \u25a1) can be found on the IBM 2741 keyboard with the APL \"golf-ball\" print head inserted, these became available in the mid 1960s while ALGOL 68 was being drafted. These characters are also part of the unicode standard and most of them are available in several popular fonts:","Transput is the term used to refer to ALGOL 68's input and output facilities. There are pre-defined procedures for unformatted, formatted and binary transput. Files and other transput devices are handled in a consistent and machine-independent manner. The following example prints out some unformatted output to the standard output device:","Note the predefined procedures newpage and newline passed as arguments.","The transput is considered to be of books, channels and files:","\"Formatted transput\" in ALGOL 68's transput has its own syntax and patterns (functions), with formats embedded between two $ characters. Examples:","ALGOL 68 supports programming of parallel processing. Using the keyword par, a collateral clause is converted to a parallel clause, where the synchronisation of actions is controlled using semaphores. In A68G the parallel actions are mapped to threads when available on the hosting operating system. In A68S a different paradigm of parallel processing was implemented (see below).","This sample program implements the Sieve of Eratosthenes to find all the prime numbers that are less than 100. nil is the ALGOL 68 analogue of the null pointer in other languages. The notation x of y accesses a member x of a struct y.","Note: The Soviet Era computers \u042d\u043b\u044c\u0431\u0440\u0443\u0441-1 (Elbrus-1) and \u042d\u043b\u044c\u0431\u0440\u0443\u0441-2 were created using high-level language u\u042d\u043b\u044c-76 (AL-76), rather than the traditional assembly. u\u042d\u043b\u044c-76 resembles Algol-68, The main difference is the dynamic binding types in u\u042d\u043b\u044c-76 supported at the hardware level. u\u042d\u043b\u044c-76 is used for application, job control, system programming.","Both ALGOL 68C and ALGOL 68R are written in ALGOL 68, effectively making ALGOL 68 an application of itself. Other applications include:","A feature of ALGOL 68, inherited from ALGOL tradition, is its different representations. There is a representation language used to describe algorithms in printed work, a strict language (rigorously defined in the Report) and an official reference language intended to be used in actual compiler input. In the examples above you will observe underlined words. This is the formal representation of the language. ALGOL 68's reserved words are effectively in a different namespace from identifiers, and spaces are allowed in identifiers, so the fragment:","is legal. The programmer who actually writes the code does not have the option of underlining the code. Depending on hardware and cultural issues, different methods to denote these identifiers, have been devised, called stropping regimes. So all or some of the following may be possible programming representations:","All implementations must recognise at least POINT, UPPER and RES inside PRAGMAT sections.","The following characters were recommended for portability, and termed \"worthy characters\" in the Report on the Standard Hardware Representation of Algol 68:","This reflected a problem in the 1960s where some hardware didn't support lower-case, nor some other non ASCII characters, indeed in the 1973 report it was written: \"Four worthy characters -- \"|\", \"_\", \"[\", and \"]\" -- are often coded differently, even at installations which nominally use the same character set.\"","ALGOL 68 allows for every natural language to define its own set of keywords Algol-68. As a result, programmers are able to write programs using keywords from their native language. Below is an example of a simple procedure that calculates \"the day following\", the code is in two languages: English and German[citation needed].","","Russian\/Soviet example: In English Algol68's reverent case statement reads case ~ in ~ out ~ esac, in Cyrillic this reads \u0432\u044b\u0431 ~ \u0432 ~ \u043b\u0438\u0431\u043e ~ \u0431\u044b\u0432.","For its technical intricacies, ALGOL 68 needs a cornucopia of methods to deny the existence of something:","c.f. below for other examples of \u2135.","The term nil is var always evaluates to true for any variable (but see above for correct use of is\u00a0:\/=:), whereas it is not known to which value a comparison x < skip evaluates for any integer x.","ALGOL 68 leaves intentionally undefined what happens in case of integer overflow, the integer bit representation, and the degree of numerical accuracy for floating point. In contrast, the language Java has been criticized for over-specifying the latter.","Both official reports included some advanced features that were not part of the standard language. This were indicated with an \u2135 and considered effectively private. Examples include \"\u226e\" and \"\u226f\" for templates, the outtype\/intype for crude duck typing, and the straightout and straightin operators for \"straightening\" nested arrays and structures.","Extract from the 1973 report:","Except where noted (with a superscript), the language described above is that of the \"Revised Report(RR)\".","The original language(FR) differs in syntax of the mode cast, and it had the feature of proceduring, i.e. coercing the value of a term into a procedure which evaluates the term. Proceduring would be intended to make evaluations lazy. The most useful application could have been the short-circuited evaluation of boolean operators. In","b is only evaluated if a is true. As defined in ALGOL 68, it did not work as expected, for example in the code:","against the programmers na\u00efve expectations the print would be executed as it is only the value of the elaborated enclosed-clause after andf that was procedured. Textual insertion of the commented-out proc bool: makes it work.","Some implementations emulate the expected behaviour for this special case by extension of the language.","Before revision, the programmer could decide to have the arguments of a procedure evaluated serially instead of collaterally by using semicolons instead of commas (gommas).","For example in:","The first argument to test is guaranteed to be evaluated before the second, but in the usual:","then the compiler could evaluate the arguments in whatever order it felt like.","After the revision of the report, some extensions to the language have been proposed to widen the applicability:","So far, only partial parametrisation has been implemented, in ALGOL68G.","The S3 programming language that was used to write the ICL VME operating system and much other system software on the ICL 2900 Series was a direct derivative of Algol 68. However, it omitted many of the more complex features, and replaced the basic modes with a set of data types that mapped directly to the 2900 Series hardware architecture.","ALGOL 68R(R) from RRE was the first ALGOL 68 subset implementation, running on the ICL 1900. Based on the original language, the main subset restrictions were definition before use and no parallel processing. This compiler was popular in UK universities in the 1970s, where many computer science students learnt ALGOL 68 as their first programming language; the compiler was renowned for good error messages.","ALGOL 68RS(RS) from RSRE was a portable compiler system written in ALGOL 68RS (bootstrapped from ALGOL 68R), and implemented on a variety of systems including the ICL 2900\/Series 39, Multics and DEC VAX\/VMS. The language was based on the Revised Report, but with similar subset restrictions to ALGOL 68R. This compiler survives in the form of an Algol68-to-C compiler.","In ALGOL 68S(S) from Carnegie Mellon University the power of parallel processing was improved by adding an orthogonal extension, eventing. Any variable declaration containing keyword event made assignments to this variable eligible for parallel evaluation, i.e. the right hand side was made into a procedure which was moved to one of the processors of the C.mmp multiprocessor system. Accesses to such variables were delayed after termination of the assignment.","Cambridge ALGOL 68C(C) was a portable compiler that implemented a subset of ALGOL 68, restricting operator definitions and omitting garbage collection, flexible rows and formatted transput.","ALGOL 68G(G) by M. van der Veer is an ALGOL 68 implementation for today's computers and operating systems. A minor restriction is that (formatted) transput does not fully conform to the Revised Report.","\"Despite good intentions, a programmer may violate portability by inadvertently employing a local extension. To guard against this, each implementation should provide a PORTCHECK pragmat option. While this option is in force, the compiler prints a message for each construct that it recognizes as violating some portability constraint.\""]}