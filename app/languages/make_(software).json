{"name":"make","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Make_(software)","description":["In software development, Make is a utility that automatically builds executable programs and libraries from source code by reading files called makefiles which specify how to derive the target program. Though integrated development environments and language-specific compiler features can also be used to manage a build process, Make remains widely used, especially in Unix.","There are now a number of dependency-tracking build utilities, but Make is one of the most widespread, primarily due to its inclusion in Unix, starting with the PWB\/UNIX 1.0, which featured a variety of tools targeting software development tasks. It was originally created by Stuart Feldman in 1977 at Bell Labs. In 2003 Dr. Feldman received the ACM Software System Award for the authoring of this widespread tool.","Before Make's introduction, the Unix build system most commonly consisted of operating system dependent \"make\" and \"install\" shell scripts accompanying their program's source.[citation needed] Being able to combine the commands for the different targets into a single file and being able to abstract out dependency tracking and archive handling was an important step in the direction of modern build environments.","Make has gone through a number of rewrites, including a number of from-scratch variants which used the same file format and basic algorithmic principles and also provided a number of their own non-standard enhancements. Some of them are:","POSIX includes standardization of the basic features and operation of the Make utility, and is implemented with varying degrees of completeness in Unix-based versions of Make. In general, simple makefiles may be used between various versions of Make with reasonable success. GNU Make and BSD Make can be configured to look first for files named \"GNUmakefile\" and \"BSDmakefile\" respectively, which allows one to put makefiles which use implementation-defined behavior in separate locations.","Make is typically used to build executable programs and libraries from source code. Generally though, any process that involves transforming a source file to a target result (by executing arbitrary commands) is applicable to Make. For example, Make could be used to detect a change made to an image file (the source) and the transformation actions might be to convert the file to some specific format, copy the result into a content management system, and then send e-mail to a predefined set of users that the above actions were performed.","Make is invoked with a list of target file names to build as command-line arguments:","Without arguments, Make builds the first target that appears in its makefile, which is traditionally a symbolic \"phony\" target named all.","Make decides whether a target needs to be regenerated by comparing file modification times. This solves the problem of avoiding the building of files which are already up to date, but it fails when a file changes but its modification time stays in the past. Such changes could be caused by restoring an older version of a source file, or when a network filesystem is a source of files and its clock or timezone is not synchronized with the machine running Make. The user must handle this situation by forcing a complete build. Conversely, if a source file's modification time is in the future, it triggers unnecessary rebuilding, which may inconvenience users.","Make searches the current directory for the makefile to use, e.g. GNU make searches files in order for a file named one of GNUmakefile, makefile, Makefile and then runs the specified (or default) target(s) from (only) that file.","The makefile language is similar to declarative programming. This class of language, in which necessary end conditions are described but the order in which actions are to be taken is not important, is sometimes confusing to programmers used to imperative programming.","One problem in build automation is the tailoring of a build process to a given platform. For instance, the compiler used on one platform might not accept the same options as the one used on another. This is not well handled by Make. This problem is typically handled by generating platform specific build instructions, which in turn are processed by Make. Common tools for this process are Autoconf and CMake.","A makefile consists of rules. Each rule begins with a textual dependency line which defines a target followed by a colon (:) and optionally an enumeration of components (files or other targets) on which the target depends. The dependency line is arranged so that the target (left hand of the colon) depends on components (right hand of the colon). It is common to refer to components as prerequisites of the target.","For example, a C .o object file is created from .c files, so you need to have .c files first (i.e. specific object file target depends on a C source file and header files). Because Make itself does not understand, recognize or distinguish different kinds of files, this opens up a possibility for human error. A forgotten or an extra dependency may not be immediately obvious and may result in subtle bugs in the generated software. It is possible to write makefiles which generate these dependencies by calling third-party tools, and some makefile generators, such as the Automake toolchain provided by the GNU Project, can do so automatically.","After each dependency line, a series of command lines may follow which define how to transform the components (usually source files) into the target (usually the \"output\"). If any of the components have been modified, the command lines are run.","Make can decide where to start through topological sorting.","Each command line must begin with a tab character to be recognized as a command. The tab is a whitespace character, but the space character does not have the same special meaning. This is problematic, since there may be no visual difference between a tab and a series of space characters. This aspect of the syntax of makefiles is often subject to criticism.","Each command is executed by a separate shell or command-line interpreter instance. Since operating systems use different command-line interpreters this can lead to unportable makefiles. For instance, GNU Make by default executes commands with \/bin\/sh, where Unix commands like cp are normally used. In contrast to that, Microsoft's nmake executes commands with cmd.exe where batch commands like copy are available but not necessarily cp.","Usually each rule has a single unique target, rather than multiple targets.","A rule may have no command lines defined. The dependency line can consist solely of components that refer to targets, for example:","The command lines of a rule are usually arranged so that they generate the target. An example: if \"file.html\" is newer, it is converted to text. The contents of the makefile:","The above rule would be triggered when Make updates \"file.txt\". In the following invocation, Make would typically use this rule to update the \"file.txt\" target if \"file.html\" were newer.","Command lines can have one or more of the following three prefixes:","Ignoring errors and silencing echo can alternatively be obtained via the special targets \".IGNORE\" and \".SILENT\".","Microsoft's NMAKE has predefined rules that can be omitted from these makefiles, e.g. \"c.obj $(CC)$(CFLAGS)\".","A makefile can contain definitions of macros. Macros are usually referred to as variables when they hold simple string definitions, like \"CC=gcc\". Macros in makefiles may be overridden in the command-line arguments passed to the Make utility. Environment variables are also available as macros.","Macros allow users to specify the programs invoked and other custom behavior during the build process. For example, the macro \"CC\" is frequently used in makefiles to refer to the location of a C compiler, and the user may wish to specify a particular compiler to use.","New macros (or simple \"variables\") are traditionally defined using capital letters:","A macro is used by expanding it. Traditionally this is done by enclosing its name inside $(). A rarely used but equivalent form uses curly braces rather than parenthesis, i.e. ${}.","Macros can be composed of shell commands by using the command substitution operator, denoted by backticks (`).","The content of the definition is stored \"as is\". Lazy evaluation is used, meaning that macros are normally expanded only when their expansions are actually required, such as when used in the command lines of a rule. An extended example:","The generic syntax for overriding macros on the command line is:","Makefiles can access any of a number of predefined internal macros, with '?' and '@' being the most common.","Suffix rules have \"targets\" with names in the form .FROM.TO and are used to launch actions based on file extension. In the command lines of suffix rules, POSIX specifies that the internal macro $< refers to the prerequisite and $@ refers to the target. In this example, which converts any HTML file into text, the shell redirection token > is part of the command line whereas $< is a macro referring to the HTML file:","When called from the command line, the above example expands.","Single-line comments are started with the hash symbol (#).","Some directives in makefiles can include other makefiles.","Line continuation is indicated with a backslash \\ character at the end of a line.","Makefiles are traditionally used for compiling code (*.c, *.cc, *.C, etc.), but they can also be used for providing commands to automate common tasks. One such makefile is called from the command line:","The makefile:","Below is a very simple makefile that by default (the \"all\" rule is listed first) compiles a source file called \"helloworld.c\" using the gcc C compiler and also provides a \"clean\" target to remove the generated files if the user desires to start over. The $@ and $< are two of the so-called internal macros (also known as automatic variables) and stand for the target name and \"implicit\" source, respectively. In the example below, $^ expands to a space delimited list of the prerequisites. There are a number of other internal macros.","Many systems come with predefined Make rules and macros to specify common tasks such as compilation based on file suffix. This allows user to omit the actual (often unportable) instructions of how to generate the target from the source(s). On such a system the above makefile could be modified as follows:","\nThat \"helloworld.o\" depends on \"helloworld.c\" is now automatically handled by Make. In such a simple example as the one illustrated here this hardly matters, but the real power of suffix rules becomes evident when the number of source files in a software project starts to grow. One only has to write a rule for the linking step and declare the object files as prerequisites. Make will then implicitly determine how to make all the object files and look for changes in all the source files.","Simple suffix rules work well as long as the source files do not depend on each other and on other files such as header files. Another route to simplify the build process is to use so-called pattern matching rules that can be combined with compiler-assisted dependency generation. As a final example requiring the gcc compiler and GNU Make, here is a generic makefile that compiles all C files in a folder to the corresponding object files and then links them to the final executable. Before compilation takes place, dependencies are gathered in makefile-friendly format into a hidden file \".depend\" that is then included to the makefile."]}