{"name":"Curry","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Curry_(programming_language)","description":["Curry is an experimental functional logic programming language, based on the Haskell language. It merges elements of functional and logic programming, including constraint programming integration.","It is nearly a superset of Haskell, lacking support mostly for overloading using type classes, which some implementations provide anyway as a language extension, such as the M\u00fcnster Curry Compiler.","A functional program is a set of functions defined by equations or rules. A functional computation consists of replacing subexpressions by equal (with regards to the function definitions) subexpressions until no more replacements (or reductions) are possible and a value or normal form is obtained. For instance, consider the function double defined by","The expression \u201cdouble 1\u201d is replaced by 1+1. The latter can be replaced by 2 if we interpret the operator \u201c+\u201d to be defined by an infinite set of equations, e.g., 1+1 = 2, 1+2 = 3, etc. In a similar way, one can evaluate nested expressions (where the subexpression to be replaced are quoted):","There is also another order of evaluation if we replace the arguments of operators from right to left:","In this case, both derivations lead to the same result, a property known as confluence. This follows from a fundamental property of pure functional languages, termed referential transparency: the value of a computed result does not depend on the order or time of evaluation, due to the absence of side effects. This simplifies the reasoning about and maintenance of pure functional programs.","Functional logic programs, however, are not always referentially transparent. Encapsulated searches can depend on the order of evaluation.","As functional languages like Haskell do, Curry supports the definition of algebraic data types by enumerating their constructors. For instance, the type of Boolean values consists of the constructors True and False that are declared as follows:","Functions on Booleans can be defined by pattern matching, i.e., by providing several equations for different argument values:","The principle of replacing equals by equals is still valid provided that the actual arguments have the required form, e.g.:","More complex data structures can be obtained by recursive data types. For instance, a list of elements, where the type of elements is arbitrary (denoted by the type variable a), is either the empty list \u201c[]\u201d or the non-empty list \u201ce:l\u201d consisting of a first element e and a list l:","The type \u201cList a\u201d is usually written as [a] and finite lists e1:e2:...:en:[] are written as [e1,e2,...,en]. We can define operations on recursive types by inductive definitions where pattern matching supports the convenient separation of the different cases. For instance, the concatenation operation \u201c++\u201d on polymorphic lists can be defined as follows (the optional type declaration in the first line specifies that \u201c++\u201d takes two lists as input and produces an output list, where all list elements are of the same unspecified type):","Beyond its application for various programming tasks, the operation \u201c++\u201d is also useful to specify the behavior of other functions on lists. For instance, the behavior of a function last that yields the last element of a list can be specified as follows: for all lists l and elements e, last l = e iff \u2203xs:xs++[e] = l.","Based on this specification, one can define a function that satisfies this specification by employing logic programming features. Similarly to logic languages, functional logic languages provide search for solutions for existentially quantified variables. In contrast to pure logic languages, they support equation solving over nested functional expressions so that an equation like xs++[e] = [1,2,3] is solved by instantiating xs to the list [1,2] and e to the value 3. In Curry one can define the operation last as follows:","Here, the symbol \u201c=:=\u201d is used for equational constraints in order to provide a syntactic distinction from defining equations. Similarly, extra variables (i.e., variables not occurring in the left-hand side of the defining equation) are explicitly declared by \u201cwhere...free\u201d in order to provide some opportunities to detect bugs caused by typos. A conditional equation of the form l | c = r is applicable for reduction if its condition c has been solved. In contrast to purely functional languages where conditions are only evaluated to a Boolean value, functional logic languages support the solving of conditions by guessing values for the unknowns in the condition. Narrowing as discussed in the next section is used to solve this kind of conditions.","Narrowing is a mechanism whereby a variable is bound to a value selected from among alternatives imposed by constraints. Each possible value is tried in some order, with the remainder of the program invoked in each case to determine the validity of the binding. Narrowing is an extension of logic programming, in that it performs a similar search, but can actually generate values as part of the search rather than just being limited to testing them.","Narrowing is useful because it allows a function to be treated as a relation: its value can be computed \"in both directions\". The Curry examples of the previous section illustrate this.","As noted in the previous section, narrowing can be thought of as reduction on a program term graph, and there are often many different ways (strategies) to reduce a given term graph. Antoy et al. proved in the 1990s that a particular narrowing strategy, needed narrowing, is optimal in the sense of doing a number of reductions to get to a \"normal form\" corresponding to a solution that is minimal among sound and complete strategies. Needed narrowing corresponds to a lazy strategy, in contrast to the SLD-resolution strategy of Prolog."]}