{"name":"Joy","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Joy_(programming_language)","description":["The Joy programming language in computer science is a purely functional programming language that was produced by Manfred von Thun of La Trobe University in Melbourne, Australia. Joy is based on composition of functions rather than lambda calculus. It has turned out to have many similarities to Forth, due not to design but to a sort of parallel evolution and convergence.","Joy is unusual (except for function-level programming languages and some esoteric ones, such as unlambda) in its lack of a lambda operator, and therefore lack of formal parameters. To illustrate this with a common example, here is how the square function might be defined in an imperative programming language (C):","The variable x is a formal parameter which is replaced by the actual value to be squared when the function is called. In a functional language (Scheme) the same function would be defined:","This is different in many ways, but it still uses the formal parameter x in the same way. In Joy the square function is defined:","In Joy, everything is a function that takes a stack as an argument and returns a stack as a result. For instance, the numeral '5' does not represent an integer constant, but instead a short program that pushes the number 5 onto the stack.","So the square function makes a copy of the top element, and then multiplies the two top elements of the stack, leaving the square of the original top element at the top of the stack, with no need for a formal parameter. This makes Joy concise, as illustrated by this definition of quicksort:","\"binrec\" is one of Joy's many recursive combinators, implementing binary recursion. It expects four quoted programs on top of the stack which represent:","In Joy, the meaning function is a homomorphism from the syntactic monoid onto the semantic monoid. That is, the syntactic relation of concatenation of symbols maps directly onto the semantic relation of composition of functions. It is a homomorphism instead of an isomorphism because it is onto but not one-to-one, that is, some sequences of symbols have the same meaning (e.g. \"dup +\" and \"2 *\") but no symbol has more than one meaning.","Its library routines mirror those of ISO C, though the current implementation is not easily extensible with functions written in C."]}