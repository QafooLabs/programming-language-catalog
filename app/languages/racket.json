{"name":"Racket","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Racket_(programming_language)","description":["Racket (formerly named PLT Scheme) is a multi-paradigm programming language in the Lisp\/Scheme family, that also serves as a platform for language creation, design, and implementation.","The platform provides an implementation of the Racket language (including a rich run-time system, various libraries, JIT compiler, and more) along with a development environment called DrRacket (formerly named DrScheme) written in Racket itself. The IDE and an accompanying programming curriculum is used in the ProgramByDesign outreach program, an attempt to turn computing and programming into \"an indispensable part of the liberal arts curriculum\".","The programming language is known for its extensive macro system which enables the creation of embedded and domain-specific languages, language constructs such as classes or modules, and separate dialects of Racket with different semantics. Like other dialects of Lisp, the language is also suitable for scripting and general-purpose programming.","The platform distribution is free and open source software distributed under the LGPL license. Extensions and packages written by the community are uploaded to PLaneT, a web-based package distribution system.","Matthias Felleisen founded PLT in the mid 1990s, first as a research group, soon after as a project dedicated to the production of pedagogic materials for novice programmers (lectures, exercises\/projects, software). In January 1995, the group decided to develop a pedagogic programming environment based on Scheme. Matthew Flatt cobbled together MrEd\u2014the original virtual machine for Racket\u2014from libscheme, wxWidgets, and a few other free systems. In the years that followed, a team including Flatt, Robby Findler, Shriram Krishnamurthi, Cormac Flanagan, and many others produced DrScheme, a programming environment for novice Scheme programmers and a research environment for soft typing. The main development language that DrScheme supported was called PLT Scheme.","In parallel, the team started conducting workshops for high school teachers, training them in program design and functional programming. Field tests with these teachers and their students provided essential clues for the direction of the development.","Over the following years, PLT added teaching languages, an algebraic stepper, a transparent read-eval-print loop, a constructor-based printer, and many other innovations to DrScheme, producing an application-quality pedagogic program development environment. By 2001, the core team (Felleisen, Findler, Flatt, Krishnamurthi) had also written and published their first textbook, How to Design Programs, based on their teaching philosophy.","The first generation of PLT Scheme revisions introduced features for programming in the large with both modules and classes. Version 42 introduced units\u2013a first-class module system\u2013to complement classes for large scale development. The class system gained features (e.g. Java-style interfaces) and also lost several features (e.g. multiple inheritance) throughout these versions. The language evolved throughout a number of successive versions, and gaining milestone popularity in Version 53, leading to extensive work and the following Version 100, which would be equivalent to a \"1.0\" release in current popular version systems.","The next major revision was named Version 200, which introduced a new default module system that cooperates with macros. In particular, the module system ensures that run-time and compile-time computation are separated to support a \"tower of languages.\" Unlike units, these modules are not first-class objects.","Version 300 introduced Unicode support, foreign library support, and refinements to the class system. Later on, the 300 series improved the performance of the language runtime with an addition of a JIT compiler and a switch to a default generational garbage collection.","By the next major release, the project has switched to a more conventional sequence-based version numbering. Version 4.0 introduced the #lang short-hand to specify the language that a module is written in. In addition, the revision introduced immutable pairs and lists, support for fine-grained parallelism, and a statically-typed dialect.","On June 7, 2010, PLT Scheme was renamed Racket. The renaming coincided with the release of Version 5.0. Subsequently, the GUI backend was rewritten in Racket from C++ in Version 5.1 using native UI toolkits on all platforms. Version 5.2 included an online syntax checking tool, a new plotting library, a database library, and a new extended REPL.","Racket's core language includes macros, modules, lexical closures, tail calls, delimited continuations, parameters (fluid variables), software contracts,green and OS threads, and more. Further extensions to the language are created with the powerful macro system, which together with the module system and custom parsers can control all aspects of a language. Unlike programming languages that lack macro systems, most language constructs in Racket are written on top of the base language using macros. These include a mixin class system, a component (or module) system as expressive as ML's, and pattern matching.","In addition, the language features the first contract system for a higher-order language. Racket's contract system is inspired by the Design by Contract work for Eiffel and extends it to work for higher-order values such as first-class functions, objects, reference cells, and so on. For example, an object that is checked by a contract can be insured to make contract checks when its methods are eventually invoked.","Racket's compiler is a bytecode compiler that translates to an internal bytecode format that is run by the Racket virtual machine. On x86 and PowerPC platforms, the bytecode is further compiled using a JIT compiler at runtime.","Since 2004, the language has also shipped with PLaneT, a package manager that is integrated into the module system so that third-party libraries can be transparently imported and used. Additionally, PLaneT has a built-in versioning policy to prevent dependency hell.","The feature that distinguishes Racket from other languages in the Lisp family is its integrated language extensibility. Racket's extensibility features are built into the module system to allow context-sensitive and module-level control over syntax. For example, the #%app syntactic form can be overridden to change the semantics of function application. Similarly, the #%module-begin form allows arbitrary static analysis of the entire module. Since any module can be used as a language, via the #lang notation, this effectively means a programmer can control virtually any aspect of the language.","The module-level extensibility features are combined with a Scheme-like hygienic macro system, which provides more features than Lisp's S-expression manipulation system, Scheme 84's hygienic extend-syntax macros, or R5RS's syntax-rules. Indeed, it is fair to say that the macro system is a carefully tuned application programming interface (API) for compiler extensions. Using this compiler API, programmers can add features and entire domain-specific languages in a manner that makes them completely indistinguishable from built-in language constructs.","The macro system in Racket has been used to construct entire language dialects. This includes Typed Racket\u2014a statically typed dialect of Racket that eases the migration from untyped to typed code, and Lazy Racket\u2014a dialect with lazy evaluation. Other dialects include FrTime (functional reactive programming), Scribble (documentation language), Slideshow (presentation language), and several languages for education. Racket's core distribution provides libraries to aid the process of constructing new programming languages.","Such languages are not restricted to S-expression based syntax. In addition to conventional readtable-based syntax extensions, Racket's #lang makes it possible for a language programmer to define any arbitrary parser, for example, using the parser tools library. See Racket logic programming for an example of such a language.","The language platform provides a self-hosted IDE named DrRacket, a continuation-based web server, a graphical user interface, and other tools. Racket is also a viable scripting tool and can be used for scripting the Unix shell and includes libraries like all common scripting languages.","DrRacket (formerly DrScheme) is widely used among introductory Computer Science courses that teach Scheme or Racket and is lauded for its simplicity and appeal to beginner programmers. The IDE was originally built for use with the TeachScheme! project (now ProgramByDesign), an outreach effort by Northeastern University and a number of affiliated universities for attracting high school students to computer science courses at the college level.","The editor provides source highlighting for syntax and run-time errors, parenthesis matching, a debugger and an algebraic stepper. Its student-friendly features include support for multiple \"language levels\" (Beginning Student, Intermediate Student and so on). It also has integrated library support, and sophisticated analysis tools for advanced programmers. In addition, module-oriented programming is supported with the module browser, a contour view, integrated testing and coverage measurements, and refactoring support. It provides integrated, context-sensitive access to an extensive hyper-linked help system named \"Help Desk\".","DrRacket is available for Windows (95 and up), Mac OS X, Unix, and Linux with the X Window System and programs behave similarly on all these platforms.","Here's a trivial \"hello world\" program:","Running this program produces the output:","Here's a slightly less trivial program:","This program, taken from the Racket web page, draws a Sierpinski triangle, nested to depth 8.","Using the #lang directive, a source file can be written in different dialects of Racket. Here is an example of the factorial program in Typed Racket, a statically typed dialect of Racket:","Apart from having a basis in programming language theory, Racket was designed to be used as a general-purpose language in production systems. Thus, the Racket distribution features an extensive library that covers systems and network programming, web development, a uniform interface to the underlying operating system, a dynamic foreign function interface, several flavours of regular expressions, lexer\/parser generators,logic programming, and a complete GUI framework, to name a few.","The design decision to make Racket a practical language has implications beyond the library, too. Those include Racket's ability to generate standalone executables under Windows, Mac OS X and Unix, a profiler and debugger included in the integrated development environment (IDE) and a unit testing framework.","Racket has been used for commercial projects and web applications. A notable example is the Hacker News website, which runs on Arc, which is developed in Racket. Naughty Dog has used it as a scripting language in several of their video games."]}