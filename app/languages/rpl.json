{"name":"RPL","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/RPL_(programming_language)","description":["The RPL programming language (RPL meaning ROM-based procedural language following Hewlett-Packard or, alternatively, Reverse Polish LISP) is a handheld calculator system and application programming language used on Hewlett-Packard's engineering graphing RPN calculators of the HP-28, HP-48, HP-49 and HP-50 series, but it is also usable on non-RPN calculators, such as the HP-39 series.","RPL is a structured programming language based on RPN but equally capable of processing algebraic expressions and formulae, implemented as a threaded interpreter. RPL has many similarities to Forth, both languages being stack-based, and of course the list-based LISP. Contrary to previous HP RPN calculators, which had a fixed four-level stack, the stack used by RPL is only limited by available calculator RAM.","RPL originated from HP's Corvallis, Oregon development facility in 1984 as a replacement for the previous practice of implementing the operating systems of calculators in assembly language. According to a quote by Dr. William Wickes, one of the original RPL developers, \"the development team never calls it anything but (the initials) RPL.\"","The internal low- to medium-level variant of RPL, called System RPL (or SysRPL) is used on some earlier HP calculators as well as the aforementioned ones, as part of their operating system implementation language. This variant of RPL is not accessible to the calculator user without the use of external tools. It is possible to cause a serious crash while coding in SysRPL, so caution must be used while using it. The high-level User RPL (or UserRPL) version of the language is available on said graphing calculators for developing textual as well as graphical application programs. All UserRPL programs are internally represented as SysRPL programs, but use only a safe subset of the available SysRPL commands. The error checking that is a part of UserRPL commands, however, makes UserRPL programs noticeably slower than equivalent SysRPL programs. The UserRPL command SYSEVAL tells the calculator to process designated parts of a UserRPL program as SysRPL code.","RPL control blocks are not strictly postfix. Although there are some notable exceptions, the control block structures appear as they would in a standard infix language. The calculator manages this by allowing the implementation of these blocks to skip ahead in the program stream as necessary.","RPL supports basic conditional testing through the IF\/THEN\/ELSE structure. The basic syntax of this block is:","The following example tests to see if the number at the bottom of the stack is \"1\" and, if so, replaces it with \"Equal to one\":","The IF construct evaluates the condition then tests the bottom of the stack for the result. As a result RPL can optionally support FORTH-style IF blocks, allowing the condition to be determined before the block. By leaving the condition empty, the IF statement will not make any changes to the stack during the condition execution and will use the existing result at the bottom of the stack for the test:","Postfix conditional testing may be accomplished by using the IFT (\"if-then\") and IFTE (\"if-then-else\") functions.","IFT and IFTE pop two or three commands off the stack, respectively. The topmost value is evaluated as a boolean and, if true, the second topmost value is pushed back on the stack. IFTE allows a third \"else\" value that will be pushed back on the stack if the boolean is false.","The following example uses the IFT function to pop an object from the bottom of the stack and, if it is equal to 1, replaces it with \"One\":","The following example uses the IFTE function to pop an object from the bottom of the stack and, if it is equal to 1, replaces it with \"One\". If it does not equal 1, it replaces it with the string \"Not one\":","IFT and IFTE will evaluate a program block given as one of its arguments, allowing a more compact form of conditional logic than an IF\/THEN\/ELSE\/END structure. The following example pops an object from the bottom of the stack, and replaces it with \"One\", \"Less\", or \"More\", depending on whether it is equal to, less than, or greater than 1.","To support more complex conditional logic, RPL provides the CASE\/THEN\/END structure for handling multiple exclusive tests. Only one of the branches within the CASE statement will be executed. The basic syntax of this block is:","The following code illustrates the use of a CASE\/THEN\/END block. Given a letter at the bottom of the stack, it replaces it with its string equivalent or \"Unknown letter\":","This code is identical to the following nested IF\/THEN\/ELSE\/END block equivalent:","RPL provides a FOR\/NEXT statement for looping from one index to another. The index for the loop is stored in a temporary local variable that can be accessed in the loop. The syntax of the FOR\/NEXT block is:","The following example uses the FOR loop to sum the numbers from 1 to 10. The index variable of the FOR loop is \"I\":","The START\/NEXT block is used for a simple block that runs from a start index to an end index. Unlike the FOR\/NEXT loop, the looping variable is not available. The syntax of the START\/NEXT block is:","Both FOR\/NEXT and START\/NEXT support a user-defined step increment. By replacing the terminating NEXT keyword with an increment and the STEP keyword, the loop variable will be incremented or decremented by a different value than the default of +1. For instance, the following loop steps back from 10 to 2 by decrementing the loop index by 2:","The WHILE\/REPEAT\/END block in RPL supports an indefinite loop with the condition test at the start of the loop. The syntax of the WHILE\/REPEAT\/END block is:","The DO\/UNTIL\/END block in RPL supports an indefinite loop with the condition test at the end of the loop. The syntax of the DO\/UNTIL\/END block is:"]}