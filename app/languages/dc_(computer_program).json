{"name":"dc","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Dc_(computer_program)","description":["dc is a cross-platform reverse-polish desk calculator which supports arbitrary-precision arithmetic. It is one of the oldest Unix utilities, predating even the invention of the C programming language; like other utilities of that vintage, it has a powerful set of features but an extremely terse syntax. Traditionally, the more user-friendly (with its infix notation) bc calculator program was implemented on top of dc, although more modern implementations are related in the opposite fashion: dc uses bc's library for arithmetic.","This article provides some examples in an attempt to give a general flavour of the language; for a complete list of commands and syntax, one should consult the man page for one's specific implementation.","To multiply four and five in dc (note that most of the whitespace is optional):","This translates into \"push four and five onto the stack, then, with the multiplication operator, pop two elements from the stack, multiply them and push the result back on the stack.\" Then the 'p' command is used to examine (print out to the screen) the top element on the stack.","The arithmetic precision is changed with the command 'k', which sets the number of fractional digits (the number of digits following the point) to be used for arithmetic operations. Since the default precision is zero, this sequence of commands produces '0' as a result:","By adjusting the precision with 'k', arbitrary number of decimal places can be produced. This command sequence outputs '.66666'.","To evaluate : ('v' computes the square root of the top of the stack and '_' is used to input a negative number):","To swap the top two elements of the stack, use the 'r' command. To duplicate the top element, use the 'd' command.","To read a line from stdin, use the '?' command. This will evaluate the line as if it were a dc command, and so it is necessary that it be syntactically correct and potentially be a security problem since the '!' dc command will allow arbitrary command execution.","As mentioned above, 'p' will print the top of the stack with a newline after it. 'n' will pop the top of the stack and output it without a trailing newline. 'f' will dump the entire stack with one entry per line.","dc also support arbitrary input and output radices. The 'i' command will pop the top of the stack and use it for the input base. Hex digits must be in upper case to avoid collisions with dc commands and are not limited to A-F if the input radix is larger than 16. The 'o' command does the same for the output base, but keep in mind that the input base will affect the parsing of every numeric value afterwards so it is usually advisable to set the output base first. To read the values, the 'K', 'I' and 'O' will push the current precision, input radix and output radix on to the top of the stack.","As an example, to convert from hex to binary:","outputs 11011110101011011011111011101111.","In addition to these basic arithmetic and stack operations, dc includes support for macros, conditionals and storing of results for later retrieval.","The mechanism underlying macros and conditionals is the register, which in dc is a storage location with a single character name which can be stored to and retrieved from: 'sc' pops the top of the stack and stores it in register c, and 'lc' pushes the value of register c onto the stack. For example:","Registers can also be treated as secondary stacks, so values can be pushed and popped between them and the main stack using the 'S' and 'L' commands.","String values are enclosed in '[' and ']' characters and may be pushed on the stack and stored in registers. The 'a' command will convert a the low order byte of the numeric value into an ASCII character, or if the top of the stack is a string it will replace it with the first character of the string. There are no ways to build up strings or perform string manipulation other than executing it with the 'x' command, or printing it with the 'P' command.","The '#' character begins a comment to the end of the line.","Macros are then implemented by allowing registers and stack entries to be strings as well as numbers. A string can be printed, but it can also be executed (i.e. processed as a sequence of dc commands). So for instance we can store a macro to add one and then multiply by 2 into register m:","and then (using the 'x' command which executes the top of the stack) we can use it like this:","Finally, we can use this macro mechanism to provide conditionals. The command '=r' will pop two values from the stack, and execute the macro stored in register 'r' only if they are equal. So this will print the string 'equal' only if the top of the stack is equal to 5:","Other conditionals are '>', '!>', '","Looping is then possible by defining a macro which (conditionally) reinvokes itself. A simple factorial of the top of the stack might be implemented as:","The '1Q' command will exit from a macro, allowing an early return. 'q' will quit from two levels of macros (and dc itself if there are less than two levels on the call stack). 'z' will push the current stack depth before the 'z' operation.","As an example of a relatively simple program in dc, this command (in 1 line):","will convert distances from metres to feet and inches; the bulk of it is concerned with prompting for input, printing output in a suitable format and looping round to convert another number.","As an example, here is an implementation of the Euclidean algorithm to find the GCD:","Computing the factorial of an input value, ","A more complex example performs Diffie-Hellman key exchange. This was popular as a signature block among cypherpunks during the ITAR debates:","A commented version is slightly easier to understand and shows how to use loops, conditionals, and the 'q' command to return from a macro. With a modern version of dc, the '|' command can be used to do arbitrary precision modular exponentiation without needing to write the X function."]}