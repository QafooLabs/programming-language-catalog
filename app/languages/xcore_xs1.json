{"name":"XMOS architecture","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/XCore_XS1","description":["The XCore XS1 is a 32-bit RISC microprocessor architecture designed by XMOS. The architecture is designed to be used in multi-core processors for embedded systems. Each XS1 core executes up to eight concurrent threads, each thread having its own register set, and the architecture directly supports inter-thread and inter-core communication and various forms of thread scheduling.","The architecture encodes instructions compactly, using 16 bits for frequently used instructions (with up to three operands) and 32 bits for less frequently used instructions (with up to 6 operands). Almost all instructions execute in a single cycle, and the architecture is event-driven in order to decouple the timings that a program needs to make from the execution speed of the program. A program will normally perform its computations and then wait for an event (eg a message, time, or external I\/O event) before continuing.","Processors with this architecture include the XCore XS1-G4 and XCore XS1-L1.","The architecture comprises a central execution unit that operates on a set of 25 registers, a surrounded by a number of resources that perform operations that interact with the environment. Each thread has its own set of hardware registers, enabling threads to execute concurrently. The instruction set comprises both a (more or less standard) sequential programming model, and instructions that implement multi-threading, multi-core and I\/O operations.","Instructions can use between zero and six operands. Most common arithmetic operations (such as ADD, SUB, MULT) are three-operand instructions based on a set of 12 general purpose registers. Three operands can be identified using no more than 11 bits, enabling a set of 13 frequently used 3-operand instructions to be encoded in 16 bits. Other instructions that are encoded in 16 bits are branch operations and common loads and stores.","Less frequently used instructions are encoded in 32 bits. These instructions encode instructions that operate on long immediate operands (far branches), on a large number of operands (for example long multiply which has 4 source and two destination operands) and instructions that are rarely used with fewer operands.","Each thread has access to 12 general purpose registers R0...R11. In addition there are 4 special purpose registers the SP, LR (Link register - stores the return address), CP (constant pool, points to a part of memory that stores constants) and DP (data pool - points to global variables). In addition to those 16 there are another 9 registers that store the PC, kernel PC, Exception type, Exception data, and saved copies of all those in case of an exception or interrupt. The instruction set is a load-store instruction set.","All instructions execute in a single cycle. If an instruction does not need data from memory (for example, arithmetic operations), the instruction will prefetch a word of instructions. Because most instructions are encoded in 16-bits, and because most instructions are not loads or stores (a typical number is 20% loads&stores, 80% other instructions), the prefetch mechanism can stay ahead of the instructions stream. This acts like a very small instruction cache, but its behaviour can be predicted at compile time, making timing behaviour as predictable as functional behaviour.","Instructions that access memory all use a base register: SP, DP, CP, PC or any general purpose register. In a single 16-bit instruction a thread can access:","Larger sections of memory can be accessed by means of extended instructions, which extend the above ranges to 64 KBytes.","This scheme is designed in order densely encode the common cases found in many programming patterns: access to small stack frames, a small set of globals and constants, structures, and arrays. Access to bit fields that have an odd length is facilitated by means of sign and zero extend instructions.","All common arithmetic instructions are provided - including a divide and remainder (which are the only instructions that are not single cycle). Comparison instructions compute a truth value (0 or 1) into a register, avoiding the use of flags. Many instructions have immediate version that allow a single operand with a value of between 0 and 11 inclusive, encoding many common cases such as \"i = i + 1\". In the case of bit operations such as shift, the immediate value encodes common cases. Extra instructions are provided for reversing bits and bytes, count leading zeros, digital signal processing, and long integer arithmetic.","The branch instructions include conditional and unconditional relative branches. A branch using the address in a register is provided; a relative branch which adds a scaled register operand to the program counter is provided to support jump tables. Branches to up to instructions distance are encoded in a single word. The procedure calling instructions include relative calls, calls via the constant pool, indexed calls via a dedicated register and calls via a register. Most calls within a single program module can be encoded in a single instruction; inter-module calling requires at most two instructions. It is up to the callee to save the link-register if it is not a leaf-function, a single instruction extends the stack and saves the link register.","The XS1 instruction set is designed to support both multi threading and multi-core computations. To this extent it supports channel communication (to support distributed memory computations) and barriers and locks (to support shared memory computations). A thread initiates execution on one or more newly allocated threads by setting their initial register values.","Communication between threads is performed using channels that provide full-duplex data transfer between channel-ends. This enables, amongst others, the implementation of CSP based languages, languages based on the Pi calculus. The instruction set is agnostic as to where a channel is connected to - whether that is inside a core or outside the core. Channels carry messages constructed from data and control tokens between the two channel ends. The control tokens can be used to encode communication protocols.","Channel ends have a buffer able to hold sufficient tokens to allow at least one word to be buffered. If an output instruction is executed when the channel is too full to take the data then the thread which executed the instruction is paused. It is restarted when there is enough room in the channel for the instruction to successfully complete. Likewise, when an input instruction is executed and there is not enough data available then the thread is paused and will be restarted when enough data becomes available.","A thread can, with a single instruction, synchronise with a group of threads using a barrier synchronisation. Alternatively a thread can synchronise using a lock, providing mutual exclusion. In order to communicate data when using barriers and locks, threads can either write data into the registers of another thread, or they can access memory of another thread (provided both threads execute on the same core). If shared memory is used, then the compiler or the programmer must ensure that there are no race conditions.","The XS1 architecture is event-driven. It has an instruction that can dispatch an external events in addition to traditional interrupts. If the program chooses to use events, then the underlying processor has to expect an event and wait in a specific place so that it can be handled synchronously. If desired, I\/O can be handled asynchronously using interrupts. Events and interrupts can be used on any resource that the implementation supports.","Common resources that are supported are ports (for external input and output), timers (that allow timing to a reference clock), channels (that allow communication and synchronization between threads within a core, and threads on different cores), locks (which allow controlled access to shared memory), and synchronizers (which implement barrier synchronizations between threads).","The XS1 instruction set is implemented by the XCore XS1-G4 and XCore XS1-L1. The former is a four-core processing node, the latter a single core processing node."]}