{"name":"Hamilton C shell","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Hamilton_C_shell","description":["Hamilton C shell is a clone of the Unix C shell and utilities for Microsoft Windows created by Nicole Hamilton at Hamilton Laboratories. It was first released on OS\/2 on December 12, 1988 and on Windows NT in July 1992. The OS\/2 version was discontinued in 2003 but the Windows version continues to be actively supported.","Hamilton C shell differs from the Unix C shell in several respects, its compiler architecture, its use of threads, and the decision to follow Windows rather than Unix conventions.","The original C shell used an ad hoc parser and that led to complaints about its limitations. It worked well enough for the kinds of things users typed interactively but not very well on the more complex commands a user might take time to write in a script. Attempting to pipe the output of a foreach statement into grep simply didn't work. There was a limit to how complex a command it could handle.","By contrast, Hamilton uses a top-down recursive descent parser that allows it to compile commands and procedures to an internal form before running them. As a result, statements can be nested arbitrarily.","The Unix C shell supports subshells and concurrency. A subshell is a separate child copy of the shell that inherits the current state but can then make changes, e.g., to the current directory, without affecting the parent. When the Unix C shell runs a script, it runs it in a subshell. A subshell can also be specified by putting parentheses around a group of statements. Concurrency occurs in pipelines, where all the stages are intended to run concurrently, or when a command is run in the background.","The Unix C shell's implementation of both these features depends on being able to make copies of its entire process state very inexpensively, which in turn depends on the Unix fork system call, which has access to the hardware. The semantics of fork are that it creates a child process which is a duplicate of the caller, differing only in the return value from fork. The parent and child are otherwise identical with duplicate sets of open file descriptors, duplicate current directories and duplicate memory images. The memory image, which can be quite large, is duplicated using the hardware page table and a technique called \"copy-on-write\": Initially, parent and child share the same physical pages in memory but all the pages are marked read-only. When one or the other tries to write to a page, a hardware exception is raised and the Unix kernel makes a copy of the page, gives the original to one process and the copy to the other and marks them both writable.","But Windows doesn't support a fork primitive under its native Win32 API (even though it is supported in the kernel for the POSIX subsystem), in part because Windows was conceived as graphical OS and it was unclear what it would mean to fork a graphical application with message queues. It's possible to simulate the functionality of fork on Windows at the application layer, but without access to the hardware page tables, it's awkward and not nearly as performant.","Lacking fork or a performant way to recreate that functionality, Hamilton uses the Windows threads facilities instead. When a new thread is created, it runs within the same process space and it shares all of the process state. If one thread changes the current directory or the contents of memory, it's changed for all the threads. It's much cheaper to create a thread than a process but there's no isolation between them. To recreate the missing isolation of separate processes, the threads cooperate to share resources using locks.","Finally, Hamilton differs from other Unix shells in that it follows Windows conventions instead of Unix conventions for filename slashes, escape characters, etc."]}