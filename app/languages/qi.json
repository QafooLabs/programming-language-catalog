{"name":"Qi","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Qi_(programming_language)","description":["Qi is a functional programming language developed by Dr Mark Tarver and introduced in April 2005. A new version was reimplemented and issued as Qi II in November 2008. The first version was free software, licensed under GPL. But, as GPL was perceived as unfriendly to commercial use, Qi II is available via two proprietary licenses: one for personal and educational use, and another for producing closed source software.","Qi is written in Lisp. It includes most of the features common to modern functional programming languages such as pattern-matching, currying, partial applications, guards and (optional) static type checking.","Qi was developed as part of the L21 project, which aims to modernise Lisp to meet the challenges of twenty-first century computing. In his lecture, Tarver outlined a series of current challenges to Lisp which he argued were damaging to the wider use of the language. Specifically he identified Common Lisp's lack of pattern-matching, inconsistency with respect to lambda calculus theory (partial applications being missing), procedural contamination and lack of static typing. These deficiencies, Tarver argued, had led to a general abandonment of Lisp as a teaching vehicle at university level with a concomitant lack of graduating Lisp programmers. Tarver characterised this lack of support for teaching Lisp at university as leading to a 'classic vicious cycle', whereby the small number of graduating students fluent in Lisp encouraged a transition away from using Lisp programmers which, in turn, fueled the perception that Lisp was a dying language and fed the decline in the teaching of Lisp.","In the same lecture, Tarver suggested that this problem could either be tackled at the industry or the university end, but that tackling the problem at the industry end required a champion with large amounts of capital to invest in Lisp. Tarver instead proposed to tackle the problem at the university end, by modernising Common Lisp in such a way to make it 'future proof' for at least 25 years. His characterisation of an adequate modernisation of Lisp was summarised in ten requirements which Qi was designed to meet. The solution should:","Qi makes use of the logical notation of sequent calculus to define types. This type notation, under Qi's interpretation, is actually a Turing complete language in its own right. This notation allows Qi to assign extensible type systems to Common Lisp libraries and is thought of as an extremely powerful feature of the language.","Qi compiles sequent calculus to Qi Prolog (which is incorporated into the Qi environment) via the Abstract Unification Machine (AUM). The AUM acts as a functional programming analog to the Warren abstract machine generating virtual instructions from what is essentially an extended lambda calculus. The Qi compiler maps AUM instructions to Common Lisp, and these the Lisp compiler compiles into byte code or machine code depending on the Lisp platform. The Qi environment also includes a compiler-compiler Qi-YACC which is used in the encoding of Qi to handle the parsing and reading of Qi code. Qi is thus bootstrapped or written (largely) in itself apart from a few Common Lisp functions.","As of January 2009, Qi has been updated several times since the first release (6.1) in April 2005, and the current release, Qi II 1.07, released in July, 2009, runs under both Windows and Linux on the CLISP, CMU Common Lisp, Allegro Common Lisp and Steel Bank Common Lisp (SBCL) platforms.","Qi II incorporates the following improvements over the original Qi, as follows (quoted, with minor edits, from the Lambda Associates' Qi II What's New page):","Before this, an earlier version, 9.0, incorporated an optional factoring code compiler (Turbo-E) for optimising pattern-matching. In a comparative shoot-out against several Lisp programs and OCaml, Qi 9.0 performed at the speed of the fastest and most heavily hand-optimised Lisp version. A release (Qi\/Tk) incorporating a type secure version of Tcl\/Tk embedded into Qi appeared in March 2009.","In January 2010, a successor version to Qi II was announced designed to implement many of the ideas in Tarver's lectures. The new version is designed to run under Common Lisp, Clojure and Python and is also targeted for the Dalvik Virtual Machine. Contributors include Dr Mark Tarver, Carl Shapiro of Google and Stefan Tampe.","Alternatively, the developers and proponents of the ideas set forth in Qi, have come up with a successor to Qi, dubbed Shen (programming language). Shen is a more compact language as compared to Qi, although it is mostly compatible with Qi. As such, further development on Qi may be stalled, with the result being more effort spent on Shen.","The Qi core language is a simplification of the Lisp language. Functions are written in prefix form. Symbols, variables, booleans, numbers, strings and characters are all self-evaluating if typed at the top level. Here are some examples.","Here is the traditional Hello world program in Qi:","Lists are constructed with [ .... ] with spaces separating the elements of the list.","A factorial function using pattern matching:","A lambda function in Qi that multiplies its input by 2.","The membership function using pattern-matching over lists. (Qi largely follows the Edinburgh [Prolog] syntax convention for matching (i.e. variables are headed in uppercase), except that spaces are used instead of commas to separate items.)","A function using guards that finds the first number greater than N in a list.","Static typing is optional in Qi and is enabled by (tc +) and disabled by (tc -). The type system recognises symbols, variables, strings, booleans, numbers and characters as primitive types. Primitive type operators are list, * (product), --> and array. Here are some examples","Functions are explicitly typed as with Hope. [A] is an acceptable abbreviation for the type (list A). Here is the polytype signature of member in Qi.","User-defined concrete types are defined in Qi sequent calculus. Qi sequent calculus uses a single conclusion formalism. Sequent rules have the form","where S0,...,Sn are sequent patterns. Note that S1, ...,Sn may be empty.","Side conditions in Qi are either (a) boolean tests or (b) local assignments. Here are some examples; the first uses a boolean side-condition to define an enumeration type 'fruit' containing 'apples', 'pears' and 'oranges' as the only inhabitants.","Here a type 'alphanum' is defined that is the union of the types of symbols and numbers.","Here is a (rather fatuous) use of local assignments in a type.","Lastly a more interesting recursive type for binary numbers.","Qi Prolog is a version of Prolog implemented in Qi, using a standard Edinburgh syntax, embedding the Prolog program in a string. This is a basic example of Qi Prolog:","And this is how to ask questions to the Prolog database:","Here is Einstein's Riddle in Qi Prolog. Under CMU Lisp on a 2.6\u00a0GHz Intel machine, Qi Prolog solves (ask [einsteins_riddle M]) in 0.24s (M = German) (300 KLIPS).","Qi Prolog includes an interface for calling Qi functions and the possibility of mode declarations in a similar manner to DEC-10 Prolog.","Qi YACC is an untyped compiler-compiler based on a top-down recursive descent parsing strategy. It is derived from the TDPL (top-down parsing language) and is the basis for much of the inbuilt parsing in Qi. Qi YACC takes Backus\u2013Naur Form code directly as a pseudo-code:","becomes","The following is a Qi-YACC program that parenthesises any input occurring between { ... }s.","Qi-YACC is more extensively discussed on the home site (see External Links)."]}