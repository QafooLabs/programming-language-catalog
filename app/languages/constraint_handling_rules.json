{"name":"Constraint Handling Rules","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Constraint_Handling_Rules","description":["Constraint Handling Rules (CHR) is a declarative programming language extension introduced in 1991 by Thom Fr\u00fchwirth. Originally designed for developing (prototypes of) constraint programming systems, CHR is increasingly used as a high-level general-purpose programming language. Typical application domains of CHR are abduction, multi-agent systems, natural language processing, compilation, scheduling, spatial-temporal reasoning, testing and verification, and type systems.","Although CHR is Turing complete, it is not commonly used as a programming language in its own right. Rather, it is used to extend a host language with constraints. Current host languages include Prolog, Java and Haskell. Prolog is by far the most popular host language and CHR is included in many Prolog implementations, including SICStus and SWI-Prolog.","A CHR program, sometimes called a constraint handler, is a sequence of guarded rules for simplification, propagation, and \"simpagation\" (a mix of simplification and propagation) of conjunctions of constraints. The CHR constraint store is a multi-set. In contrast to Prolog, the rules are multi-headed and are executed in a committed-choice manner using a forward chaining algorithm.","Most applications of CHRs require that the rewriting process be confluent; otherwise the results of searching for a satisfying assignment will be nondeterministic and unpredictable. Establishing confluence is usually done by way of the following three properties","The following SWI-Prolog program contains four CHR rules that implement a handler for the less-or-equal constraint:","The first rule, which is called reflexivity (rule names are optional), is a single-headed simplification rule. It removes constraints of the form A leq A from the constraint store. The second rule, antisymmetry, is a simplification rule with two heads. It replaces two symmetric leq constraints by an equality constraint (handled by Prolog unification). Simplification rules correspond to logical equivalence, as the syntax suggests. The third rule is a simpagation rule which removes redundant copies of the same constraint. Such rules are often needed because of the multi-set semantics of CHR. Finally, the last rule (transitivity) is a propagation rule that adds redundant constraints. Propagation rules correspond to logical implication.","Execution proceeds by exhaustively applying the rules to a given input query. For example, given the query A leq B, B leq C, C leq A the transitivity rule adds A leq C. Then, by applying the antisymmetry rule, A leq C and C leq A are removed and replaced by A=C. Now the antisymmetry rule becomes applicable on the first two constraints of the original query. Now all CHR constraints are eliminated so no further rules can be applied, and the answer A=C, A=B is returned."]}