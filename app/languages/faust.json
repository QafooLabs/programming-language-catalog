{"name":"FAUST","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/FAUST_(programming_language)","description":["FAUST (Functional AUdio STream) is a programming language that provides a purely functional approach to signal processing while offering a high level of performance. FAUST aims at being complementary to existing audio languages by offering a viable and efficient alternative to C\/C++ to develop signal processing libraries, audio plug-ins or standalone applications. The language is based on a simple and well defined formal semantics. A FAUST program denotes a signal processor, a mathematical function that transforms input signals into output signals.","As said in the introduction, the FAUST programming model combines a functional programming approach with a block-diagram syntax:","A FAUST program doesn\u2019t describe a sound or a group of sounds, but a signal processor, something that transforms input signals and produces output signals. The program source is organized as a set of definitions with at least the definition of the keyword process (the equivalent of main in C):","The FAUST compiler translates FAUST programs into equivalent C++ programs taking care of generating the most efficient code. The result can generally compete with, and sometimes even outperform, C++ code written by seasoned programmers. The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. Moreover the code can be easily embedded. It is self-contained and doesn\u2019t depend on any DSP library or runtime system. It has a very deterministic behaviour and a constant memory footprint. The semantic of FAUST is simple and well defined. This is not just of academic interest. It allows the FAUST compiler to be semantically driven. Instead of compiling a program literally, it compiles the mathematical function it denotes. This feature is useful for example to promote components reuse while preserving optimal performance. Moreover having access to the exact semantics of a FAUST program can simplify preservation issues FAUST is a textual language but nevertheless block-diagram oriented. It actually combines two approaches: functional programming and algebraic block-diagrams. The key idea is to view block-diagram construction as function composition. For that, FAUST relies on a block-diagram algebra of five composition operations.","Let\u2019s start with some really simple one-line examples of FAUST program. Here is a first example that produces silence:","The second example is a little bit more sophisticated and copies the input signal to the output signal. It involves the _ (underscore) primitive that denotes the identity function on signals (that is a simple audio cable for a sound engineer):","Another very simple example is the conversion of a two-channel stereo signal into a one-channel mono signal using the + primitive that adds two signals together:","Most FAUST primitives are analogue to their C counterpart on numbers, but lifted to signals. For example the FAUST primitive sin operates on a signal X by applying the C function sin to each sample X(t) of X. In other words sin transforms an input signal X into an output signal Y such that Y (t) = sin(X(t)). All C numerical functions have their counterpart in FAUST. Some signal processing primitives are specific to FAUST. For example the delay operator @ takes two input signals: X (the signal to be delayed) and D (the delay to be applied), and produces an output signal Y such that Y (t) = X(t \u2212 D(t)).","Contrary to Max-like visual programming languages where the user does manual connections, FAUST primitives are assembled in block diagrams by using a set of high-level block diagram composition operations. You can think of these composition operators as a generalization of the mathematical function composition operator.","Let\u2019s say that we want to connect the output of + to the input of abs in order to compute the absolute value of the output signal. This connection can be done using the sequential composition operator ':' (colon):","Here is an example of parallel composition (a stereo cable) using the operator ',' that puts in parallel its left and right expressions:","These operators can be arbitrarily combined. For example to multiply the input signal by 0.5 one can write:","Taking advantage of some syntactic sugar the above example can be rewritten (using what functional programmers know as curryfication):","The recursive composition operator '~' can be used to create block-diagrams with cycles (that include an implicit one-sample delay). Here is the example of an integrator that takes an input signal X and computes an output signal Y such that Y (t) = X(t) + Y(t\u22121):","Thanks to specific architecture files, a single FAUST program can be used to produce code for a variety of platforms and plug-in formats. These architecture files act as wrappers and describe the interactions with the host audio and GUI system. Currently more than 10 architectures are supported and new ones can be easily added.","A useful option makes it possible to generates the block diagram representation of the program as one or more SVG graphic files. It is interesting to note the difference between the block diagram and the generated C++ code. As already said, the key idea here is not to compile the block diagram literally, but the mathematical function it denotes. Modern C\/C++ compilers too don\u2019t compile programs literally. But because of the complex semantic of C\/C++ (due to side effects, pointer aliasing, etc.) they can\u2019t go very far in that direction. This is a distinctive advantage of a purely functional language: it allows compilers to do very advanced optimisations."]}