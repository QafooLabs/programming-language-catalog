{"name":"OCaml","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/OCaml","description":["OCaml (\u00a0\/o\u028a\u02c8k\u00e6m\u0259l\/ oh-KAM-\u0259l), originally known as Objective Caml, is the main implementation of the Caml programming language, created by Xavier Leroy, J\u00e9r\u00f4me Vouillon, Damien Doligez, Didier R\u00e9my and others in 1996. OCaml extends the core Caml language with object-oriented constructs.","OCaml's toolset includes an interactive top level interpreter, a bytecode compiler, and an optimizing native code compiler. It has a large standard library that makes it useful for many of the same applications as Python or Perl, as well as robust modular and object-oriented programming constructs that make it applicable for large-scale software engineering. OCaml is the successor to Caml Light. The acronym CAML originally stood for Categorical Abstract Machine Language, although OCaml abandons this abstract machine.","OCaml is a free open source project managed and principally maintained by INRIA. In recent years, many new languages have drawn elements from OCaml, most notably F# and Scala.","ML-derived languages are best known for their static type systems and type-inferring compilers. OCaml unifies functional, imperative, and object-oriented programming under an ML-like type system. This means the program author is not required to be overly familiar with pure functional language paradigm in order to use OCaml.","OCaml's static type system can help eliminate problems at runtime. However, it also forces the programmer to conform to the constraints of the type system, which can require careful thought and close attention. A type-inferring compiler greatly reduces the need for manual type annotations (for example, the data type of variables and the signature of functions usually do not need to be explicitly declared, as they do in Java). Nonetheless, effective use of OCaml's type system can require some sophistication on the part of the programmer.","OCaml is perhaps most distinguished from other languages with origins in academia by its emphasis on performance. Firstly, its static type system renders runtime type mismatches impossible, and thus obviates runtime type and safety checks that burden the performance of dynamically typed languages, while still guaranteeing runtime safety (except when array bounds checking is turned off, or when certain type-unsafe features like serialization are used; these are rare enough that avoiding them is quite possible in practice).","Aside from type-checking overhead, functional programming languages are, in general, challenging to compile to efficient machine language code, due to issues such as the funarg problem. In addition to standard loop, register, and instruction optimizations, OCaml's optimizing compiler employs static program analysis techniques to optimize value boxing and closure allocation, helping to maximize the performance of the resulting code even if it makes extensive use of functional programming constructs.","Xavier Leroy has stated that \"OCaml delivers at least 50% of the performance of a decent C compiler\", but a direct comparison is impossible. Some functions in the OCaml standard library are implemented with faster algorithms than equivalent functions in the standard libraries of other languages. For example, the implementation of set union in the OCaml standard library is asymptotically faster than the equivalent function in the standard libraries of imperative languages (e.g. C++, Java) because the OCaml implementation exploits the immutability of sets in order to reuse parts of input sets in the output (persistence).","OCaml features: a static type system, type inference, parametric polymorphism, tail recursion, pattern matching, first class lexical closures, functors (parametric modules), exception handling, and incremental generational automatic garbage collection.","OCaml is particularly notable for extending ML-style type inference to an object system in a general-purpose language. This permits structural subtyping, where object types are compatible, if their method signatures are compatible, regardless of their declared inheritance; an unusual feature in statically typed languages.","A foreign function interface for linking to C primitives is provided, including language support for efficient numerical arrays in formats compatible with both C and FORTRAN. OCaml also supports the creation of libraries of OCaml functions that can be linked to a \"main\" program in C, so that one could distribute an OCaml library to C programmers who have no knowledge nor installation of OCaml.","The OCaml distribution contains:","The native code compiler is available for many platforms, including Unix, Microsoft Windows, and Apple Mac OS X. Excellent portability is ensured through native code generation support for major architectures: IA-32, IA-64, AMD64, HP\/PA; PowerPC, SPARC, Alpha, MIPS, and StrongARM.","OCaml bytecode and native code programs can be written in a multithreaded style, with preemptive context switching. However, because the garbage collector of the INRIA OCaml system (which is the only currently available full implementation of the language) is not designed for concurrency, symmetric multiprocessing is not supported. OCaml threads in the same process execute by time sharing only. There are however several libraries for distributed computing such as Functory and ocamlnet\/Plasma (blog).","Snippets of OCaml code are most easily studied by entering them into the \"top-level\". This is an interactive OCaml session that prints the inferred types of resulting or defined expressions. The OCaml top-level is started by simply executing the OCaml program:","Code can then be entered at the \"#\" prompt. For example, to calculate 1+2*3:","OCaml infers the type of the expression to be \"int\" (a machine-precision integer) and gives the result \"7\".","The following program \"hello.ml\":","can be compiled into a bytecode executable:","or compiled into an optimized native-code executable:","and executed:","Lists are one of the most fundamental datatypes in OCaml. The following code example defines a recursive function sum that accepts one argument xs. (Notice the keyword rec). The function recursively iterates over a given list and provides a sum of integer elements. The match statement has similarities to C's switch element, though it is much more general.","Another way is to use standard fold function that works with lists.","OCaml lends itself to the concise expression of recursive algorithms. The following code example implements an algorithm similar to quicksort that sorts a list in increasing order.","The following program calculates the smallest number of people in a room for whom the probability of completely unique birthdays is less than 50% (the so-called birthday paradox, where for 1 person the probability is obviously 100%, for 2 it is 364\/365, etc.) (answer = 23).","The following code defines a Church encoding of natural numbers, with successor (succ) and addition (add). A Church numeral n is a higher-order function that accepts a function f and a value x and applies f to x exactly n times. To convert a Church numeral from a functional value to a string, we pass it a function that prepends the string \"S\" to its input and the constant string \"0\".","A variety of libraries are directly accessible from OCaml. For example, OCaml has a built-in library for arbitrary precision arithmetic. As the factorial function grows very rapidly, it quickly overflows machine-precision numbers (typically 32- or 64-bits). Thus, factorial is a suitable candidate for arbitrary-precision arithmetic.","In OCaml, the Num module provides arbitrary-precision arithmetic and can be loaded into a running top-level using:","The factorial function may then be written using the arbitrary-precision numeric operators =\/, *\/ and -\/\u00a0:","This function can compute much larger factorials, such as 120!:","The cumbersome syntax for Num operations can be alleviated thanks to the camlp4 syntax extension called Delimited overloading:","The following program \"simple.ml\" renders a rotating triangle in 2D using OpenGL:","The LablGL bindings to OpenGL are required. The program may then be compiled to bytecode with:","or to nativecode with:","and run:","Far more sophisticated, high-performance 2D and 3D graphical programs are easily developed in OCaml. Thanks to the use of OpenGL, the resulting programs are not only succinct and efficient, but also cross-platform, compiling without any changes on all major platforms.","The following code calculates the Fibonacci sequence of a number n inputed. It uses tail recursion and pattern matching.","MetaOCaml is a multi-stage programming extension of OCaml enabling incremental compiling of new machine code during runtime. Under certain circumstances, significant speedups are possible using multi-stage programming, because more detailed information about the data to process is available at runtime than at the regular compile time, so the incremental compiler can optimize away many cases of condition checking etc.","As an example: if at compile time it is known that a certain power function x -> x^n is needed very frequently, but the value of n is known only at runtime, you can use a two-stage power function in MetaOCaml:","As soon as you know n at runtime, you can create a specialized and very fast power function:","The result is:","The new function is automatically compiled.","The private trading firm Jane Street Capital has adopted OCaml as its preferred language."]}