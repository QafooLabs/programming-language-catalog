{"name":"Charm","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Charm_(language)","description":["Charm (language) is an object oriented computer programming language devised in the early 1990s with similarities to the RTL\/2, Pascal and C languages in addition to containing some unique features of its own. The Charm language is defined by a context-free grammar amenable to being processed by recursive descent parser as described in seminal books on compiler design.","A set of Charm tools including a compiler, assembler and linker released for the Acorn market has been reviewed in Acorn User magazine under the category of programming software. Charm reworked for RISC OS platforms has subsequently been reviewed in Archive magazine","The definition of the Charm grammar in Backus\u2013Naur Form along with descriptive examples of Charm constructs is defined on the Charm language page.","The language is block structured, with each block being introduced by a language keyword that is descriptive of the operation being performed in the block e.g. for, while, repeat (iteration), case, if (selection). Each block is enclosed by { and } delimiters. Additionally language lines within a block are normally indented for clarity, though this not required as white space is ignored.","Each grammatically conforming text represents a collection of executable code and associated data which can be used by a Charm tool set as a component when assembling a program that can be run under an operating system utilising the services it provides to do useful work such as data processing or interacting with users through a Graphical user interface.","Charm is a strongly typed language, but does allow some implicit conversions between numeric and floating point types. The following basic variable types are supported:","Data aggregates of the same type may be declared and statically initialised using the array keyword, and these may be multidimensional. Aggregates of different types may be declared using the record keyword, and it is allowable for such a declaration to define a union of record fields that overlay each other in terms of storage allocation. Modules may also aggregate a mixture of static and dynamic data members. Instances of both records and modules (dynamic content only) can be instantiated on the stack, or on the heap via the new operator. Modules may also define a constructor ~new procedure to initialise dynamic data and corresponding ~delete deconstructor procedure to release resources in a similar manner to the C++ language.","Data or procedures within the scope of a module may be made global to the final application by using the export keyword. If a module wishes to reference a procedure or data from another Charm module, it does so using the import keyword. Modules may contain instance based member variables which are accessible through procedures declared with the dynamic keyword through the implicit first parameter this pointer.","References to data constructs and procedures may be made using the ref keyword. These can be dereferenced using the val keyword. When using reference variables, comparison operators are available to check whether two reference variables refer to the same item of data (\u00a0:=: ) or whether the data they point to is the same ( = ).","The original classic Hello world program written in Charm is:","and the equivalent latest version following evolutionary syntactic language changes is:","Tool set implementations are expected to provide a compiler and an assembler to generate object files from Charm source code and assembler source code, which can then be linked together along with library and run time support files to generate an executable program.","At the time of writing only one Charm tool set installation is available (free of charge) for download. The tools are themselves written in the Charm language, and the source code is available under the terms of the GNU General Public License. They run on RISC OS PCs and platforms with ARM CPUs (such as the Raspberry Pi) and on emulators for RISC OS which are hosted on Windows or Linux platforms (such as RPCEmu).","The Charm compiler is a recursive descent single pass compiler which parses Charm source code to generate quadruples of the form result\u00a0:= lhs op rhs in an intermediate language that supports arithmetic, logical and flow of control operations. Data is stored in temporaries which are assigned to registers and memory locations in the back end of the compiler. Two back ends are currently in existence, one generating Motorola 68000 assembly language, and the other generating ARM Architecture.","The quadruple output from the hello world example is:","and the assembler output is:","Note that in more recent releases of Charm, the I\/O procedures have been split into their own modules In and Out. Other standard library procedures are organised into a set of records with procedure references as fields. As part of this reorganisation, the write_string method is now invoked through the run time library module Out via static member reference .vdu as procedure str i.e. in the hello world example above write_string (\"Hello world\") becomes Out.vdu.str (\"Hello world\").","The assembler accepts instruction mnemonics, data declarations and directives and constructs an object file containing information readily understandable by the CPU of the target processor, in particular code instructions coded in binary.","One and only one of the Charm modules linked to form an executable program must contain a procedure matching one of the signatures:","This is analogous to the main function in the C and Java languages. Here argc contains the number of parameters passed on the command line and argv contains a reference to an array of argc + 1 strings (one string per positional parameter in order and a terminating nil).","In addition, modules may optional contain static startup and shutdown procedures invoked during program startup and shutdown that match the signatures:","The linker adds any necessary header information required by the operating system in order to execute the program, and ensures the run time library assembler support code is run which sets up the run time environment (data and stack pointers) and passes control to the start procedure of the application.","A map file showing the names of all modules linked to form the program along with global data and code references is optionally produced which can be used by debuggers and profilers."]}