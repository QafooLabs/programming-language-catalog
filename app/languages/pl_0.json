{"name":"PL\/0","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/PL\/0","description":["At least two programming languages are known as PL\/0. One is a subset of IBM's general-purpose programming language PL\/I.","The other PL\/0, covered here, is similar to but much simpler than the general-purpose programming language Pascal, intended as an educational programming language. It serves as an example of how to construct a compiler. It was originally introduced in the book, Algorithms + Data Structures = Programs, by Niklaus Wirth in 1975. It features quite limited language constructs: there are no real numbers, very few basic arithmetic operations and no control-flow constructs other than \"if\" and \"while\" blocks. While these limitations make writing real applications in this language impractical, it helps the compiler remain compact and simple.","The following is the syntax rules of the model language defined in EBNF:","It is rather easy for students to write a recursive descent parser for such a simple syntax. Therefore, the PL\/0 compiler is still widely used in courses on compiler construction throughout the world. Due to the lack of features in the original specification, students usually spend most of their time with extending the language and their compiler. They usually start with introducing REPEAT .. UNTIL and continue with more advanced features like parameter passing to procedures or data structures like arrays, strings or floating point numbers.","The main article on compilers honours PL\/0 for introducing several influential concepts (stepwise refinement, recursive descent parsing, EBNF, P-code, T-diagrams) to the field by educating students to use these concepts. Over the last 3 decades, most university courses on compiler construction that used PL\/0 have followed Wirth strictly in employing these techniques (see references below). Some years ago university courses dared to deviate from the course set by Wirth with the replacement of the classical recursive descent parsing technique by a (nonetheless classical) Unix-like approach of employing lex and yacc. Only recently an implementation (PL\/0 Language Tools) along this way has also combined modern concepts like object-orientation and design patterns with a modern scripting language (Python), allowing students to consume the source text of the implementation in a contemporary programming style.","In December 1976, Wirth wrote a small booklet about compiler construction, containing the full source code of the PL\/0 compiler. The syntax rules above were taken from this first edition of Wirth's book Compilerbau. In later editions of this book (under the influence of his ongoing research) Wirth changed the syntax of PL\/0. He changed the spelling of keywords like const and procedure to uppercase. This change made PL\/0 resemble Modula-2 more closely. At the same time, Wirth's friend and collaborator C. A. R. Hoare was working on his influential communicating sequential processes concept, which used the exclamation mark ! and the question mark ? to denote communication primitives. Wirth added both symbols to the PL\/0 language, but he did not mention their semantics in the book.","The following example is taken from such an extended language called PL\/0E.","This program outputs the squares of numbers from 1 to 10. Most courses in compiler construction today have replaced the exclamation mark with the WriteLn procedure.","The following example was taken from the second edition of Wirth's book Compilerbau, which appeared in 1986 in Germany.","In the third and last edition of his book on compiler construction, Wirth replaced PL\/0 with Oberon-0. The compiler is still presented in its entirety, although the language Oberon-0 is much more complex than PL\/0. For example. Oberon-0 offers arrays, records, type declarations and procedure parameters. The publisher of Wirth's books (Addison-Wesley) has decided to phase out all his books, but Wirth revised the third edition of his book in 2005 and the result is now available online."]}