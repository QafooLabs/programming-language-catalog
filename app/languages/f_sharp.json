{"name":"F#","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/F_Sharp_(programming_language)","description":["F# (pronounced F Sharp) is a multi-paradigm programming language, targeting the .NET Framework, that encompasses functional programming as well as imperative and object-oriented programming disciplines. It is a variant of ML and is largely compatible with the OCaml implementation. F# was initially developed by Don Syme at Microsoft Research but is now being developed at Microsoft Developer Division and is being distributed as a fully supported language in the .NET Framework and Visual Studio.","F# is a strongly typed language that uses type inference. As a result, data types do not need to be explicitly declared by the programmer; they will be deduced by the compiler during compilation. However, F# also allows explicit data type declaration. Being a CLI compliant language, F# supports all CLI types and objects but it extends the type system and categorizes types as immutable types or mutable types. CLI objects classify as mutable types (which can be edited in-place), and are used to provide an object-oriented programming model. Immutable types (editing such a type creates a new instance without overwriting the older one) are primarily used for functional programming.","Like ML, F# includes a functional programming component supporting eager evaluation. For functional programming, it provides several constructs and a set of immutable types: tuples, records, discriminated unions and lists.","An n-tuple represents a collection of n values, where n \u2265 0. The value n is called the arity of the tuple. The type unit corresponds to the 0-tuple and it has one value only: (), which conveys no information. The type unit is used to implement functions that need no input and\/or return no value. A 3-tuple would be represented as (A, B, C), where A, B and C are values of possibly different types. A tuple can be used only to store values when the number of values is known at design-time and stays constant throughout execution.","A record is a specialization of tuple where the data members are named, as in { Name:string; Age:int }. Records can be created as { Name=\"AB\"; Age=42 }. The with keyword is used to create a copy of a record, as in { r with Name=\"CD\" }, which creates a new record by copying r and changing the value of the Name field (assuming the record created in the last example was named r).","The list type is a regular linked list represented either using a head::tail notation (:: is the cons operator) or a shorthand as [item1; item2; item3]. An empty list is written [].","The other sort of algebraic data type mentioned, \"discriminated unions\" (type-safe versions of C unions), can be defined to hold a value of any of a pre-defined type. For example,","can hold values as instantiated by either constructor. The type of the values the constructors will act on can be defined as well.","Constructors are used to create a view of the data type different from the actual implementation, as required for supporting the Active Patterns concept. Data types are created with the type keyword. F# uses the let keyword for binding type values to a name (variable).","F# uses pattern matching to resolve names into values. It is also used when accessing discriminated unions. Functions using a discriminated union provide different expressions to be invoked, associated with the data type in the union. The union is matched against these data types, and the expression associated with the match is invoked. F# also supports the Active Patterns pattern. It is used, for example, when a type needs to provide multiple views. For example, an exponential number will provide, as well as the base and exponents, the final value.","All functions in F# are instances of the function type, and are immutable as well. Functions can be curried. Being an instance of a type, functions can be passed as arguments to other functions, resulting in higher order functions. F# supports lambda functions and closures as well. Like other functional programming languages, F# allows function composition using the >> operator. Every statement in F#, including if statements and loops, is a composable expression with a definite return type as well. Functions and expressions that do not return any value have a return type of unit.","The F# extended type system is implemented as generic .NET types. The Record type creates a .NET class with the field names as properties. Tuples are generic classes of type Tuple. The number of type parameters define the number and types of the elements in the tuple. Discriminated unions are implemented as tagged unions. Functions are of type FastFunc with type parameters specifying the parameter and return types.","F#, like other .NET languages, can use .NET types and objects, using an imperative object-oriented style of programming. For imperative programming, F# supports for and while loops, arrays (created with the [| ... |] syntax, and number sequences written in shorthand as in 1 .. 25) and support for creating Object types (equivalent to .NET classes). F# also allows extending the syntax to support embedding custom domain-specific languages within the F# language itself.","F# provides sequence expressions that allows for a defining a sequence block (seq { ... } or [ ... ] or [| ... |]) encapsulating constructs (either functions, conditional expressions or loops) that act on a collection and another function (or lambda), such that the function is invoked on the results yielded from the collection-processing expressions. For example, seq { for b in 0 .. 25 do if b < 15 then yield b*b } is a sequence expression that forms a sequence of squares of numbers from 0 to 14 by filtering out numbers from the range of numbers from 0 to 25. The sequence is lazily evaluated, i. e., the collection is processed and results yielded on-demand. It can be used for filtering and is the basis of support for LINQ queries. Sequence expressions are generalized as Computation Expressions which are equivalent to monads.","Sequence expressions and computation expressions are also used for creating asynchronous workflows. An asynchronous workflow is defined as a sequence of commands inside a async{ ... }, as in","The let! allows the rest of the async block to be defined as the delegate and passed as the callback function of an asynchronous operation. This helps deal with inversion of control issues. The async block is invoked using the Async.Run function. Multiple async blocks are executed in parallel using the Async.Parallel function that takes a list of async objects (in the example, asynctask is an async object) and creates another async object to run the tasks in the lists in parallel. The resultant object is invoked using Async.Run.","F# comes with a Microsoft Visual Studio language service that integrates it with the IDE. With the language service installed, Visual Studio can be used to create F# projects and the Visual Studio debugger used to debug F# code. In addition, it comes with a Visual Studio-hosted interactive console that executes F# code as it is being written.","SharpDevelop supports F# as well since version 3.0.","LINQPad supports F# as well since version 2.x.","A few small samples follow:","A simple example that is often used to demonstrate the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#:","Recursive function examples:"]}