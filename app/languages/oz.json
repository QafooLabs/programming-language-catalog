{"name":"Oz","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Oz_(programming_language)","description":["Oz is a multiparadigm programming language, developed in the Programming Systems Lab at Universit\u00e9 catholique de Louvain, for programming language education. It has a canonical textbook: Concepts, Techniques, and Models of Computer Programming.","Oz was first designed by Gert Smolka and his students in 1991. In 1996 the development of Oz continued in cooperation with the research group of Seif Haridi and Peter Van Roy at the Swedish Institute of Computer Science. Since 1999, Oz has been continually developed by an international group, the Mozart Consortium, which originally consisted of Saarland University, the Swedish Institute of Computer Science, and the Universit\u00e9 catholique de Louvain. In 2005, the responsibility for managing Mozart development was transferred to a core group, the Mozart Board, with the express purpose of opening Mozart development to a larger community.","The Mozart Programming System is the primary implementation of Oz. It is released with an open source license by the Mozart Consortium. Mozart has been ported to different flavors of Unix, FreeBSD, Linux, Microsoft Windows, and Mac OS X.","Oz contains most of the concepts of the major programming paradigms, including logic, functional (both lazy and eager), imperative, object-oriented, constraint, distributed, and concurrent programming. Oz has both a simple formal semantics (see chapter 13 of the book mentioned below) and an efficient implementation[citation needed]. Oz is a concurrency-oriented language, as the term was introduced by Joe Armstrong, the main designer of the Erlang language. A concurrency-oriented language makes concurrency both easy to use and efficient. Oz supports a canonical GUI language QTk.","In addition to multi-paradigm programming, the major strengths of Oz are in constraint programming and distributed programming. Due to its factored design, Oz is able to successfully implement a network-transparent distributed programming model. This model makes it easy to program open, fault-tolerant applications within the language. For constraint programming, Oz introduces the idea of \"computation spaces\"; these allow user-defined search and distribution strategies orthogonal to the constraint domain.","Oz is based on a core language with very few datatypes that can be extended into more practical ones through syntactic sugar.","Basic data structures:","Those data structures are values (constant), first class and dynamically type checked.","Functions are first class values, allowing higher order functional programming:","When the program encounters an unbound variable it waits for a value:","It is not possible to change the value of a dataflow variable once it is bound:","Dataflow variables make it easy to create concurrent stream agents:","Because of the way dataflow variables works it is possible to put threads anywhere in the program and it is guaranteed that it will have the same result. This makes concurrent programming very easy. Threads are very cheap: it is possible to have a hundred thousand threads running at once.","This example computes a stream of prime numbers using the Trial division algorithm by recursively creating concurrent stream agents that filter out non-prime numbers:","Oz uses eager evaluation by default, but lazy evaluation is possible:","The declarative concurrent model can be extended with message passing through simple semantics:","With a port and a thread the programmer can define asynchronous agents:","It is again possible to extend the declarative model to support state and object-oriented programming with very simple semantics; we create a new mutable data structure called Cells:","With these simple semantic changes we can support the whole object-oriented paradigm. With a little syntactic sugar OOP becomes well integrated in Oz.","The execution speed of a program produced by the Mozart Compiler (version 1.4.0 implementing Oz 3) is very slow. On a set of benchmarks it is on average about 50 times slower than that of the gcc compiler for the C language, solving the benchmarks-tasks."]}