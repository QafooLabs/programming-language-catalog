{"name":"Hume","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Hume_(language)","description":["Hume is a functionally based programming language developed at the University of St Andrews and Heriot-Watt University in Scotland since the year 2000. The language name is both an acronym meaning 'Higher-order Unified Meta-Environment' and an honorific to the 18th Century philosopher David Hume. It targets real-time embedded systems, aiming to produce a design that is both highly abstract, yet which will still allow precise extraction of time and space execution costs. This allows programmers to guarantee the bounded time and space demands of executing programs.","Hume is unusual in combining functional programming ideas with ideas from finite state automata. Automata are used to structure communicating programs into a series of \"boxes\", where each box maps inputs to outputs in a purely functional way using high-level pattern-matching. It is also unusual in being structured as a series of levels, each of which exposes different machine properties, which is highly unusual.","The Hume language design attempts to maintain the essential properties and features required by the embedded systems domain (especially for transparent time and space costing) whilst incorporating as high a level of program abstraction as possible. It aims to target applications ranging from simple micro-controllers to complex real-time systems such as smartphones. This ambitious goal requires incorporating both low-level notions such as interrupt handling, and high-level ones of data structure abstraction etc. Of course such systems will be programmed in widely differing ways, but the language design should accommodate these varying requirements.","Hume is a three-layer language: an outer (static) declaration\/metaprogramming layer, an intermediate coordination layer describing a static layout of dynamic processes and the associated devices, and an inner layer describing each process as a (dynamic) mapping from patterns to expressions. The inner layer is stateless and purely functional.","Rather than attempting to apply cost modeling and correctness proving technology to an existing language framework either directly or by altering a more general language (as with e.g. RTSJ), the approach taken by the Hume designers is to design Hume in such a way that formal models and proofs can definitely be constructed. Hume is structured as a series of overlapping language levels, where each level adds expressibility to the expression semantics, but either loses some desirable property or increases the technical difficulty of providing formal correctness\/cost models."]}