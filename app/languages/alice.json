{"name":"Alice","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Alice_(programming_language)","description":["Alice ML is a functional programming language designed by the Programming Systems Lab at Saarland University. It is a dialect of Standard ML, augmented with support for lazy evaluation, concurrency (multithreading and distributed computing via remote procedure calls) and constraint programming.","Alice extends Standard ML in a number of ways that distinguish it from its predecessor. Alice provides concurrency features as part of the base language through the use of a \u201cfuture\u201d type that represents a value being provided by an independent thread of execution. A thread that uses a future value will block on an attempt to access the value until the thread performing it has completed the computation. A related concept is also provided known as a \"promise\", allowing a thread to provide a future value that it will compute to another thread. Future and promise typed variables are used to implement data-flow synchronization.","Alice also provides facilities to allow programmers to use a lazy evaluation strategy in their programs versus the traditional eager evaluation strategy that Standard ML takes. The Haskell language is a functional language that also provides lazy evaluation. Alice adopts an eager evaluation model by default, requiring the programmer to explicitly state that a computation is to be evaluated lazily. This differs from Haskell, which adopts the lazy model by default.","The Alice implementation from Saarland University uses the SEAM (Simple Extensible Abstract Machine) virtual machine. It is free software, and features just-in-time compilation to bytecode as well as native code for the x86 architecture.","Early versions of Alice ran on the Mozart\/Oz VM, allowing interfacing between Alice and Oz code.","Alice's remote procedure calling depends on the virtual machine, because it may actually send code to be computed from one computer to another.","Alice extends Standard ML with several primitives for lazy evaluation and concurrency. For example, threads may be created using the spawn keyword. Consider the naive algorithm for computing the Fibonacci numbers:","For large values of n, fib n will take a long time to compute. This computation can be performed in a separate thread by","The variable x is now bound to a so-called \"future\". When an operation requires the actual value of x, it blocks until the thread is done with the computation. To exploit parallelism one could even define fib as follows:"]}