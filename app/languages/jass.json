{"name":"JASS","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/JASS","description":["JASS or JASS2 (sometimes said to stand for Just Another Scripting Syntax)[citation needed] is an event driven scripting language used in Blizzard Entertainment's Warcraft III game and its expansion pack The Frozen Throne. Map creators can use it in the World Editor to create scripts for triggers and AI (artificial intelligence) in custom maps and campaigns.","The language provides an extensive API that gives programmers control over nearly every aspect of the game world. It can, for example, execute simple GUI functions such as giving orders to units, changing the weather and time of day, playing sounds and displaying text to the player, and manipulating the terrain. JASS can also create powerful functions such as trackables, which detect if a mouse goes over or hits a position, GetLocalPlayer(), which can cause disconnects\u00a0if used improperly (such as using handles with GetLocalPlayer() ). It has a syntax similar to Turing and Delphi, but unlike those languages, it is case sensitive. JASS primarily uses procedural programming concepts, though popular user-made modifications to Blizzard's World Editor program have since added C++-like object-oriented programming features to the syntax of JASS.","The following function creates a string containing the message \"Hello, world!\" and displays it to all players:","or if you want this only for one player:","And if you want to print the message 90 times and show the iterator:","Syntax of JASS is similar to Turing. It is context free. Examples of basic syntax are shown below:","JASS is statically-typed, and its types can be separated into two classes: natives and handles. The native types are:","All other types are considered non-native. The native types behave very similarly to primitive types in other programming languages. Handle types, however, behave more like objects. Handle types often represent an \"object\" within the game (units, players, special effects, etc.). Similarly to how Java treats Objects, all variables and parameters in JASS of handle types are treated as values, but in reality those values are nothing but references to the handle objects. This becomes important when dealing with garbage collection because handles, if not properly cleaned up, can cause significant performance issues. Additionally, local variables do not properly dereference handles when they go out of scope. If they are not nullified properly, handle indices will not be garbage collected and will eventually leak. Also, any references to handles themselves take up some memory space. Users may experience reduced performance if they are not nullified, though on a much smaller scale.","Another property of handle types worth noting is that all handle types are treated as if they were children of the \"handle\" type. Some of these children types have their own children types, and so on. Handle variables may reference its own specific handle type or any children type. For example:","Since patch 1.24b there is a new handle-based type called \"agent\" which has been introduced to separate handle types of which objects has to be deleted manually (Dynamic memory allocation) and handle types of which objects are deleted automatically (Stack-based memory allocation). For example types \"unit\", \"rect\" or \"destructable\" which refer to dynamic allocated objects do extend type \"agent\" now whereas types such as \"race\" or \"alliancetype\" which actually are only some kind of wrappers for the native type \"integer\" and can be compared to enumerated types do still extend type \"handle\".","Of the primitive types, type casting between integer, real, and string is officially supported by the language. JASS supports both implicit and explicit type casting.","Implicit casting only occurs from real to integer. For example:","The JASS library provides several functions for explicit type casting:","An important property of handle types related to type casting is that since all variables of handles are just references, they can all be treated (and are treated) as integers. Each instance of a handle is assigned a unique integer value that essentially acts as an identifier for the handle. Therefore, type casting from handles to integers, although technically not supported by JASS, is possible in practice because implicit casting from handle types to integer can and will occur if the code is written in a certain way, for example:","If the game ever reached the line \"return h\", it would in fact actually cast the handle to an integer and return the value. However, Blizzard never intended for JASS to be used this way, and so the JASS compiler will actually throw an error, warning the programmer that the function isn't returning the correct type. However, JASS programmers have found and exploited a now famous bug in the JASS compiler's syntax checker: the so-called \"return bug\". Essentially, the compiler will only make sure that the last return statement in a function returns the correct type. Therefore, the following code compiles without error and can be used to cast handles to integers","This bug has been fixed in patch 1.23b, although it was not completely fixed until patch 1.24b. Users have to use new hashtable natives instead of their return bug counterparts. While this bug has been fixed in patch 1.24b, another return bug has been discovered by users, known as the Return Nothing bug. The Return Nothing bug has been fixed by Blizzard in patch 1.23c.","The return nothing bug lets the user get the last value returned by any function, even as another type. To properly utilize the bug, the desired return must be made in a separate function and a return in the calling function should be made impossible.","JASS supports one-dimensional arrays of any type (excluding code). The syntax to declare arrays and access members in an array is outlined in the code below.","One limitation of arrays in JASS is that they cannot be returned by functions or passed as parameters to other functions, though array members may be returned (in a function that returns a unit, u may be returned if u is an array of type unit).","Blizzard Entertainment has decided to deprecate any use of return bugs with Warcraft III patch 1.24. This is done as an attempt to fix certain security vulnerabilities. Once the patch is deployed, any map that contains the script code with returns bugs will not run properly. All maps using return bugs must use newly available hashtable natives to be compatible with newer versions.","The patch is currently applied on all Battle.net servers.","vJass is a set of user-made extensions to JASS. It introduces object-oriented programming features to the language, such as structs, encapsulation, and polymorphism. Strictly speaking, vJass does not add anything to the JASS library but instead mostly uses JASS arrays and integers used as their indices. The extension relies on a custom-made compiler that compiles vJass code to strict JASS code. In this manner, no additional mods for either the World Editor program or Warcraft III are required, and maps made using vJass code are fully compatible with any copy of the game, even those without the compiler. The most convenient Tool for Map-Developers which want to use vJass is currently the JassNewGen-Pack, which includes several enhancements for the Warcraft III-World-Editor (including a vJass precompiler).","The JASS interpreter of Warcraft III up to version 1.23 doesn't check memory region boundaries. This allows execution of arbitrary bytecode through a map, meaning that practically anything, including malware (viruses, trojans, etc.), can be engineered into a map to be executed and infect a computer. Blizzard Entertainment is aware of this issue and applied a temporary workaround to games hosted on Battle.net. They are also preparing a permanent fix for LAN and single-player games. This issue was addressed with the release of version 1.24.","In 2010, the Warcraft III Jass community found a way to exploit the I\/O capabilities of the Preload native (Commonly used to preload files during initialization to prevent lag), by using it to run malicious code on a players computer. There are several maps that exploit these capabilities by forcing your computer to download files from the internet. The Preload native allows you to download files over the internet, create files on your computer, move files on your computer, delete files and much more. You must only play maps hosted by a source that you trust."]}