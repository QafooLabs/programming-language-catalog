{"name":"SuperCollider","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/SuperCollider","description":["SuperCollider is an environment and programming language originally released in 1996 by James McCartney for real-time audio synthesis and algorithmic composition.","Since then it has been evolving into a system used and further developed by both scientists and artists working with sound. It is an efficient and expressive dynamic programming language providing a framework for acoustic research, algorithmic music, and interactive programming.","Released under the terms of the GNU General Public License in 2002, SuperCollider is free software. The most recent major release (3.5) was released in March 2012.","Starting with version 3, the SuperCollider environment has been split into two components: a server, scsynth; and a client, sclang. These components communicate using OSC (Open Sound Control).","SC Language combines the object oriented structure of Smalltalk and features from functional programming languages with a C family syntax.","The SC Server application supports a simple C plugin API making it easy to write efficient sound algorithms (unit generators), which can then be combined into graphs of calculations. Because all external control in the server happens via OSC, it is possible to use it with other languages or applications.","SuperCollider's sound generation is bundled into an optimised command-line executable (named scsynth). In most cases it is controlled from within the SuperCollider programming language, but it can be used independently. The audio server has the following features:","Supernova, an independent implementation of the Server architecture, adds multi-processor support through explicit parallel grouping of synthesis nodes.","The SuperCollider programming language is a dynamically typed, garbage-collected, single inheritance object-oriented and functional language similar to Smalltalk, with a syntax similar to Ruby or the C programming language. Its architecture strikes a balance between the needs of realtime computation and the flexibility and simplicity of an abstract language. Like many functional languages, it implements functions as first class objects, which may be composed. Functions and methods can have default argument values and variable length argument lists and can be called with any order of keyword arguments. Closures are lexical, and scope is both lexical and dynamic. Further features typical of functional languages are supported, including closure creation via partial application (explicit currying), tail call optimization, list comprehensions, and coroutines. Specifics include the implicit expansion of tuples and the stateless pattern system. Its constant time message lookup and real time garbage collection allows large systems to be efficient and to handle signal processing flexibly.","By supporting methods of reflective, conversational, and literate programming, SuperCollider makes it relatively easy to find new sound algorithms and to develop custom software as well as custom frameworks. With regards to domain specific knowledge, it is both general (e.g., it allows to represent properties such as time and pitch in variable degrees of abstraction) and copious of example implementations for specific purposes.","The SuperCollider language allows users to construct cross-platform graphical user interfaces for applications. The standard class library with user interface components may be extended by a number of available frameworks. For interactive programming, the system supports programmatic access to rich text code files. It may be used to generate vector graphics algorithmically.","Because the server is controlled using Open Sound Control (OSC), a variety of applications can be used to control the server. SuperCollider language environments (see below) are typically used, but other OSC-aware systems can be used such as Pure Data.","\"Third-party\" clients for the SuperCollider server exist, including rsc3, a Scheme client, hsc3, based on Haskell, ScalaCollider, based on Scala, and Overtone, based on Clojure. These are distinct from the development environments mentioned below because they do not provide an interface to SuperCollider's programming language, instead they communicate directly with the audio server and provide their own approaches to facilitating user expression.","SuperCollider runs under Mac OS X, Linux, Windows and FreeBSD. The Windows version, however, tends to lag behind the others since most development is based on Mac and Linux. For each of these operating systems there are multiple language-editing environments and clients that can be used with SuperCollider (see below).","It has also been demonstrated that SuperCollider can run on iOS and Android.","The Mac version of SuperCollider is most commonly used from within its own Mac-specific (Cocoa) interface; on Windows and Linux, various editors and a number of common development environments can be used, such as:","For each of the above environments, a plugin enables the real-time execution of SuperCollider code and interaction with the audio server.","Previous attempts to port SuperCollider to Windows have also resulted in a Python-based development environment (named PsyCollider), and a plug-in for the Eclipse IDE, but have not been updated recently. However, a new effort is currently undertaken to develop a cross-platform IDE based on the Qt framework.","As a versatile dynamic programming language, SuperCollider can be used for live coding, i.e. performances which involve the performer modifying and executing code on-the-fly. Specific kinds of proxies serve as high level placeholders for synthesis objects which can be swapped in and out or modified at runtime. Environments allow sharing and modification of objects and process declarations over networks. Various extension libraries support different abstraction and access to sound objects, e.g. dewdrop_lib allows for the live creation and modification of pseudo-classes and -objects."]}