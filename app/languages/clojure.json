{"name":"Clojure","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Clojure","description":["Clojure (pronounced like \"closure\") is a recent dialect of the Lisp programming language created by Rich Hickey. It is a functional general-purpose language. Its focus on programming with immutable values and explicit progression-of-time constructs are intended to facilitate the development of more robust programs, particularly multithreaded ones.","Clojure runs on the Java Virtual Machine, Common Language Runtime, and JavaScript engines. Like other Lisps, Clojure treats code as data and has a sophisticated macro system.","Rich Hickey is the creator of the Clojure programming language. Before Clojure, he developed dotLisp, a similar project based on the .NET platform. Hickey spent about 2\u00bd years working on Clojure before releasing it to the world, much of that time working exclusively on Clojure without external funding. At the end of this period Hickey sent an email announcing the language to some friends in the Common Lisp community.","Hickey developed Clojure because he wanted a modern Lisp for functional programming, symbiotic with the established Java platform, and designed for concurrency.","Clojure's approach to concurrency is characterized by the concept of identities, which represent a series of immutable states over time. Since states are immutable values, any number of workers can operate on them in parallel, and concurrency becomes a question of managing changes from one state to another. For this purpose, Clojure provides several mutable reference types, each having well-defined semantics for the transition between states.","Like most other Lisps, Clojure's syntax is built on S-expressions that are first parsed into data structures by a reader before being compiled. Clojure's reader supports literal syntax for maps, sets and vectors in addition to lists, and these are given to the compiler as they are. In other words, the Clojure compiler does not compile only list data structures, but supports all of the mentioned types directly. Clojure is a Lisp-1, and is not intended to be code-compatible with other dialects of Lisp.","Clojure's macro system is very similar to that in Common Lisp with the exception that Clojure's version of the backquote (called \"syntax quote\") qualifies symbols with their namespace. This helps prevent unintended name capture as binding to namespace-qualified names is forbidden. It is possible to force a capturing macro expansion, but this must be done explicitly. Clojure also disallows rebinding global names in other namespaces that have been imported into the current namespace.","Variations on the Clojure language have been developed for platforms other than the JVM:","Hello world:","Defining a function:","GUI Hello World by calling the Java Swing library:","A thread-safe generator of unique serial numbers (though note that like many other Lisp dialects, Clojure has a built-in gensym function for this purpose):","An anonymous subclass of java.io.Writer that doesn't write to anything, and a macro using that to silence all prints within it:","10 Threads manipulating one shared data structure, which consists of 100 vectors each one containing 10 (initially sequential) unique numbers. Each thread then repeatedly selects two random positions in two random vectors and swaps them. All changes to the vectors occur in transactions by making use of clojure's software transactional memory system. That's why even after 100 000 iterations of each thread no number got lost.","Output of previous example:",""]}