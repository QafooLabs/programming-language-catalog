{"name":"CIL","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Common_Intermediate_Language","description":["Common Intermediate Language (CIL, pronounced either \"sil\" or \"kil\") (formerly called Microsoft Intermediate Language or MSIL) is the lowest-level human-readable programming language defined by the Common Language Infrastructure (CLI) specification and is used by the .NET Framework and Mono. Languages which target a CLI-compatible runtime environment compile to CIL, which is assembled into an object code that has a bytecode-style format. CIL is an object-oriented assembly language, and is entirely stack-based. Its bytecode is translated into native code or executed by a virtual machine.","CIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of C# and the Common Language Infrastructure, the bytecode is now officially known as CIL.","During compilation of CLI programming languages, the source code is translated into CIL code rather than platform or processor-specific object code. CIL is a CPU- and platform-independent instruction set that can be executed in any environment supporting the Common Language Infrastructure, such as the .NET runtime on Windows, or the cross-platform Mono runtime. In theory, this eliminates the need to distribute different executable files for different platforms and CPU types. CIL code is verified for safety during runtime, providing better security and reliability than natively compiled executable files.","The execution process looks like this:","CIL bytecode has instructions for the following groups of tasks:","The Common Intermediate Language is object-oriented and stack-based. That means that data are pushed on a stack instead of pulled from registers like in most CPU architectures.","In x86 it might look like this:","The corresponding code in IL can be rendered as this:","Here are two locals that are pushed on the stack. When the add-instruction is called the operands get popped and the result is pushed. The remaining value is then popped and stored in the first local.","This extends to object-oriented concepts as well. You may create objects, call methods and use other types of members such as fields.","CIL is designed to be object-oriented and every method needs (with some exceptions) to reside in a class. So does this static method:","This method does not require any instance of Foo to be declared because it is static. That means it belongs to the class and it may then be used like this in C#:","In CIL:","Instance classes","An instance class contains at least one constructor and some instance members. This class has a set of methods representing actions of a Car-object.","Creating objects","In C# class instances are created like this:","And these statements are roughly the same as these instructions:","Invoking instance methods","Instance methods are invoked like the one that follows:","In CIL:","CLI records information about compiled classes as Metadata. Like the type library in the Component Object Model, this enables applications to support and discover the interfaces, classes, types, methods, and fields in the assembly. The process of reading such metadata is called reflection.","Metadata can be data in the form of attributes. Attributes can be custom made by extending from the Attribute class. This is a very powerful feature.","Below is a basic Hello, World program written in CIL. It will display the string \"Hello, world!\".","The following code is more complex in number of opcodes.","This code can also be compared with the corresponding code in the article about Java bytecode.","In CIL syntax it looks like this:","This is just a representation of how CIL looks like near VM-level. When compiled the methods are stored in tables and the instructions are stored as bytes inside the assembly, which is a Portable Executable (PE).","A CIL assembly and instructions are generated by either a compiler or a utility called the IL Assembler (ILASM) that is shipped with the execution environment.","Assembled IL can also be disassembled into code again using the IL Disassembler (ILDASM). There are other tools such as .NET Reflector that can decompile IL into a high-level language (e.g. C# or Visual Basic). This makes IL a very easy target for reverse engineering. This trait is shared with Java bytecode. However, there are tools that can obfuscate the code, and do it so that the code cannot be easily readable but still be runnable.","Just-in-time compilation involves turning the byte-code into code immediately executable by the CPU. The conversion is performed gradually during the program's execution. JIT compilation provides environment-specific optimization, runtime type safety, and assembly verification. To accomplish this, the JIT compiler examines the assembly metadata for any illegal accesses and handles violations appropriately.","CLI-compatible execution environments also come with the option to do a Ahead-of-time compilation (AOT) of an assembly to make it execute faster by removing the JIT process at runtime.","In the .NET Framework there is a special tool called the Native Image Generator (NGEN) that performs the AOT. In Mono there is also an option to do an AOT."]}