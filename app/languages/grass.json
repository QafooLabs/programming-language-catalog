{"name":"GRASS","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/GRASS_(programming_language)","description":["GRASS (GRAphics Symbiosis System) was a programming language created to script 2D vector graphics animations. GRASS was similar to BASIC in syntax, but added numerous instructions for specifying 2D object animation, including scaling, translation, rotation and color changes over time. It quickly became a hit with the artistic community who were experimenting with the new medium of computer graphics, and will remain most famous for its use by Larry Cuba to create the original \"attacking the death star will not be easy\" animation in Star Wars. A later version that was adapted to support raster graphics was known as ZGrass.","The original version of GRASS was developed by Tom DeFanti for his 1974 Ohio State University Ph.D. thesis. It was developed on a PDP-11\/45 driving a Vector General 3DR display, and as the name implies, this was a purely vector graphics machine. GRASS included a number of vector-drawing commands, and could organize collections of them into a hierarchy, applying the various animation effects to whole \"trees\" of the image at once (stored in arrays). It was this version that was used for the Star Wars animation, if you re-watch this portion of the film you can see object trees popping into the image at various times.","After graduation, DeFanti moved to the University of Illinois, Chicago Circle. There he joined up with Dan Sandin and together they formed the Circle Graphics Habitat (today known as the Electronic Visualization Laboratory, or EVL). Sandin had joined the university in 1971 and set about building what he thought of as the video version of a Moog synthesizer, known as the Sandin Image Processor, or IP. The IP was an analog computer which took two video inputs, mixed them, colored the results, and then re-created TV output.","DeFanti added the existing GRASS system as the input to the IP, creating the GRASS\/Image Processor, which was used throughout the mid-1970s. In order to make the system more useful, DeFanti and Sandin added all sorts of \"one-off\" commands to the existing GRASS system, but these changes also made the language considerably more idiosyncratic. In 1977 another member of the Habitat, Nola Donato, re-designed many of GRASS's control structures into more general forms, resulting in the considerably cleaner GRASS3.","Larry Cuba's Star Wars work is based on a rear projection filming of a the GRASS system running on a vector terminal. As the terminal holds the vectors (and points) in internal memory, the system is able to make basic transformations - scaling, rotation, etc. - in realtime without interacting with the computer or language. It is only during the times when new scenery is being presented that the much slower communications with the GRASS language takes place. This can be seen in the sequence, as the initial sections of the film show the Death Star being rotated and scaled very rapidly, while the later sections simulating flight down the trench requires new scenery to be paged in from GRASS \"trees\", which is easily visible.","In 1977 DeFanti was introduced to Jeff Frederiksen, a chip designer working at Dave Nutting Associates. Nutting had been contracted by Midway, the videogame division of Bally, to create a standardized graphics driver chip. They intended to use it in most of their future arcade games, as well as a video game console they were working on which would later turn into the Astrocade. Midway was quite interested in seeing the GRASS language running on their system, and contracted DeFanti to port it to the platform. A number of people at the Habitat, as well as some from Nutting, worked on the project, which they referred to as the Z Box. GRASS3 running on it became Zgrass.","The Z-Box was a raster graphics machine, unlike the original GRASS systems, so while most of the GRASS3 style was maintained in Zgrass, it added a number of commands dedicated to raster images. This included an extensive set of bit block transfer commands in order to simulate sprites, something the hardware didn't include. The work would never be released by Midway, but the Circle would produce machines based on it as the Datamax UV-1.","The last version of GRASS was RT\/1, a port of GRASS to other platforms that divorced the language from the display model and allowed it to be ported to other platforms. Versions existed for DOS, Windows, SGI platform using OpenGL, HP-UX, AIX, Macintosh and Amiga. The language remains similar to the earlier versions, so the reason for the change of name is unclear.","Zgrass was based on a standard set of BASIC commands and used most of its syntax. Where Zgrass differed from BASIC was that all commands were in fact functions and returned values, similar to the C programming language. If there was no obvious return value it was expected that a function would return 1 if it succeeded, and 0 if it failed. For instance, the command PRINT PRINT 10 would be illegal in BASIC, but in Zgrass this would print 10 1, the 1 being the value returned by second PRINT, meaning \"I successfully output the string '10'\".","Programs in Zgrass were referred to as \"macros\", and stored as strings. Both of these oddities were deliberate, as Zgrass allowed any string to become a program. For instance, MYBOX=\"BOX 0,0,100,100,2\" defines a string (no need for a $ as in BASIC) containing a snippet of Zgrass code. Simply typing MYBOX from that point on would run the command(s) inside. This feature can be used in place of the more traditional GOSUB command from BASIC, but has the added advantage of having a well defined name as opposed to an opaque line number. In addition the command remains a string, and can be manipulated at runtime with standard string operations.","Most BASIC interpreters of the era converted the input text into a \"tokenized\" version in which each of the commands was replaced by a single number (typically one byte long). This made the program run faster because it didn't have to continually decode the commands from the strings every time. Zgrass's use of string-based macros made this difficult, so they didn't bother with tokenization. Instead they included a compiler which could be used on any particular macro, speeding it up many times. Programs would often consist of a mix of compiled and uncompiled macros.","Line numbers were optional in Zgrass, and typically only appeared on lines that were the target of a GOTO. Most BASIC interpreters required line numbers for every line of code, but this was due to their use in the \"line editor\"\u2013if you needed to edit that line, the only way to refer to it was by number. Zgrass used a more advanced full-screen editor that eliminated this need.[notes 1] Zgrass allowed any string to act as a \"line number\", GOTO 10 and GOTO MARKER were both valid. Zgrass also included nameless branches, using the SKIP instruction, which would move forward or back a given number of lines.","In keeping with its original purpose as a graphics language, Zgrass included numerous commands for simple drawing. Zgrass's coordinate system was based on that of the original graphics chip that Nutting had designed, based on a 320\u00d7202 grid. The Astrocade, for unknown reasons, used only half the resolution, a 160\u00d7101 display. To avoid potential mapping problems, the coordinate space's zero point was placed in the center of the screen. \u2212160 to 160 were valid X locations, and -101 to 101 valid Y locations. For use on the Astrocade you used the positive locations only, whereas on the UV-1 the entire space was available.","Zgrass added a fairly complete set of array functions, as arrays are widely used in graphics. This included the ability to \"capture\" parts of the display into an array as a bitmap, which could then be manipulated as any other graphic item. This allowed Zgrass to include sprite-like functionality in the language, something the Nutting hardware did not include. Another feature the Astrocade did not include was the ability to process arrays with any reasonable speed, so the UV-1 included the Zilog supplied FPU for added performance.","Zgrass included three priorities (called levels) that allowed macros to be run normally, or in \"foreground\" or \"background\" levels. This added a simple form of multitasking which was tremendously useful in an animation-oriented language. Game authors could place joystick-reading routines in a macro set to run in the background, and then the joystick would be read automatically whenever the current drawing macro completed. Functions placed in the foreground ran before either, and was often used for timers and other \"low latency\" needs. Zgrass included a TIMEOUT function that would call macros on a timed basis, making the implementation of timers very easy.","Zgrass also included a series of commands that \"covered\" CP\/M, which allowed the disk to be accessed without exiting to the command prompt. You could easily save out macros to named files, and load them in the same way, allowing you to construct programs by loading up various macros from the disk into one large program. The commands also automatically made a backup copy of every save. Similar features were supported for cassette tape storage, but oddly the syntax was marred, disk commands were D-something, like DPUT while tape commands were something-TAPE, like PUTTAPE.[notes 2]","With programs constructed from randomly selected modules, Zgrass needed to have better control over its variables than BASIC. In BASIC all variables are \"global\", so if two subroutines both use the variable i (very common) then they could set each other's values leading to hard to debug problems. Under Zgrass a programmer loading up two modules would almost certainly find that both used i as a loop counter, and thus could cause problems. To address this problem, Zgrass allowed one to use lowercase letters for variables, in which case the variable was local only to that macro. Oddly the examples provided with the language do not make widespread use of this feature, potentially confusing new programmers who might not be aware the feature even exists.","This text creates a new macro called SINCURVE that can be called simply by typing SINCURVE into the command prompt, or from other macros or programs. SINCURVE uses two local variables, x and angle, as well as a global variable, OFFSET.","The PROMPT\/INPUT is a modification of the original BASIC INPUT, which will not ask for the input if the user types it into the command line when calling the macro. In this case typing SINCURVE will result in the prompt appearing and the program waiting for input, whereas typing SINCURVE 30 will skip the prompt and OFFSET will automatically be assigned 30. This allows a single macro to be used both interactively and within a program as a function.","POINT is an example of one of the many graphics commands included in the Zgrass language. POINT requires an X and Y location, as well as a color. In this example the user supplied OFFSET moves the x position of the curve on the screen, while the Y position is supplied by the trig function, suitably enlarged for display (in this case, 80 times). The color is supplied in the last input, and in this case is 3. The UV-1 used color registers, so 3 did not imply a particular color, but a color selected from the current palette.","The IF is likewise interesting. It places an increment, (x=x+1), in front of the test, a feature not normally available in BASIC. In this case the IF is told to call SKIP -2 if true, which will move back two lines and can be used in place of a GOTO."]}